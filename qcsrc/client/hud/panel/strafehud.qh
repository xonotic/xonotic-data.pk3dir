#pragma once
#include "../panel.qh"
#include <client/hud/panel/strafehud/_mod.qh>

AUTOCVAR_SAVE(hud_panel_strafehud, int, 3, "enable this panel, \"1\" = show if not observing, \"2\" = show always, \"3\" = show only in Race/CTS if not observing");
AUTOCVAR_SAVE(_hud_panel_strafehud_demo, bool, false, "StrafeHUD changes angle during configure");
AUTOCVAR_SAVE(hud_panel_strafehud_dynamichud, bool, true, "apply the dynamic HUD effects to this panel");
AUTOCVAR_SAVE(hud_panel_strafehud_mode, int, 0, "StrafeHUD mode which controls whether the StrafeHUD is centered at \"0\" = view angle, \"1\" = velocity angle");
AUTOCVAR_SAVE(hud_panel_strafehud_range, float, 90, "the angle range up to 360 degrees displayed on the StrafeHUD; \"-1\" = current fov, \"0\" = dynamic (chooses the minimum range required to still see the whole area needed for accelerating)");
AUTOCVAR_SAVE(hud_panel_strafehud_range_sidestrafe, float, -2, "the angle range up to 360 degrees displayed on the StrafeHUD when side strafing, \"0\" = dynamic (chooses the minimum range required to still see the whole area needed for accelerating), \"-1\" = current fov, \"-2\" = same as the normal range");
AUTOCVAR_SAVE(hud_panel_strafehud_style, int, 2, "\"0\" = no styling, \"1\" = progress bar style for the strafe bar, \"2\" = accelerated gradient for the strafe bar (no nonlinear projection for gradient color/opacity), \"3\" = software gradient for the strafe bar (slow)");
AUTOCVAR_SAVE(hud_panel_strafehud_unit_show, bool, true, "show units");
AUTOCVAR_SAVE(hud_panel_strafehud_onground_mode, int, 2, "handling of landing at speeds where friction is higher than optimal acceleration; \"0\" = fill the whole HUD with overturn, \"1\" = show zones regardless, \"2\" = show the zones as if airborne (useful for quake2 and quake3 physics)");
AUTOCVAR_SAVE(hud_panel_strafehud_onground_friction, bool, true, "account for friction in calculations");

AUTOCVAR_SAVE(hud_panel_strafehud_timeout_ground, float, 0.1, "time (in seconds) after take off before changing to air strafe physics when not jumping (visually more consistent HUD while on downwards slick ramps)");
AUTOCVAR_SAVE(hud_panel_strafehud_timeout_turn, float, 0.1, "time (in seconds) after releasing the strafe keys before changing mode (visually more consistent HUD while switching between left/right strafe turning)");
AUTOCVAR_SAVE(hud_panel_strafehud_antiflicker_angle, float, 0.01, "how many degrees from 0° to 180° the HUD ignores if it could cause visual disturbances otherwise (and to counter rounding errors)");
AUTOCVAR_SAVE(hud_panel_strafehud_fps_update, float, 0.5, "update interval (in seconds) of the frametime to calculate the optimal angle, smaller values may cause flickering");

AUTOCVAR_SAVE(hud_panel_strafehud_bar_preaccel, bool, true, "extend the acceleration zone by the strafe meter zone before full acceleration can be achieved");
AUTOCVAR_SAVE(hud_panel_strafehud_bar_preaccel_color, vector, '0 1 0', "color of the strafe meter pre-acceleration zone");
AUTOCVAR_SAVE(hud_panel_strafehud_bar_preaccel_alpha, float, 0.5, "opacity of the strafe meter pre-acceleration zone");
AUTOCVAR_SAVE(hud_panel_strafehud_bar_neutral_color, vector, '1 1 1', "color of the strafe meter neutral zone");
AUTOCVAR_SAVE(hud_panel_strafehud_bar_neutral_alpha, float, 0.1, "opacity of the strafe meter neutral zone");
AUTOCVAR_SAVE(hud_panel_strafehud_bar_accel_color, vector, '0 1 0', "color of the strafe meter acceleration zone");
AUTOCVAR_SAVE(hud_panel_strafehud_bar_accel_alpha, float, 0.5, "opacity of the strafe meter acceleration zone");
AUTOCVAR_SAVE(hud_panel_strafehud_bar_overturn_color, vector, '1 0 1', "color of the strafe meter overturn zone");
AUTOCVAR_SAVE(hud_panel_strafehud_bar_overturn_alpha, float, 0.5, "opacity of the strafe meter overturn zone");

AUTOCVAR_SAVE(hud_panel_strafehud_angle_alpha, float, 0.8, "opacity of the indicator showing the player's current angle");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_preaccel_color, vector, '0 1 1', "color of the indicator showing the player's current angle if it is within the pre-acceleration zone");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_neutral_color, vector, '1 1 0', "color of the indicator showing the player's current angle if it is within the neutral zone");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_accel_color, vector, '0 1 1', "color of the indicator showing the player's current angle if it is within the acceleration zone");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_overturn_color, vector, '1 0 1', "color of the indicator showing the player's current angle if it is within the overturn zone");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_line, int, 0, "defines the number of dashes of the indicator line showing the player's current angle; \"0\" = no line, \"1\" = solid line");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_line_width, float, 0.001, "width of the indicator line showing the player's current angle (relative to the panel width)");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_line_height, float, 1, "height of the indicator line showing the player's current angle (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_arrow, int, 1, "arrow style of the angle indicator showing the player's current angle; \"0\" = none, \"1\" = top, \"2\" = bottom, \"3\" = both");
AUTOCVAR_SAVE(hud_panel_strafehud_angle_arrow_size, float, 0.5, "arrow size of the indicator showing the player's current angle (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_bestangle, int, 1, "\"1\" = enable a ghost angle indicator showing the best angle to gain maximum acceleration, \"2\" = only when side strafing");
AUTOCVAR_SAVE(hud_panel_strafehud_bestangle_color, vector, '1 1 1', "color of the indicator showing the best angle to gain maximum acceleration");
AUTOCVAR_SAVE(hud_panel_strafehud_bestangle_alpha, float, 0.5, "opacity of the indicator showing the best angle to gain maximum acceleration");
AUTOCVAR_SAVE(hud_panel_strafehud_bestangle_line, int, 0, "defines the number of dashes of the best angle indicator line; \"0\" = no line, \"1\" = solid line");
AUTOCVAR_SAVE(hud_panel_strafehud_bestangle_line_width, float, 0.001, "width of the best angle indicator line (relative to the panel width)");
AUTOCVAR_SAVE(hud_panel_strafehud_bestangle_line_height, float, 1, "height of the best angle indicator line (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_bestangle_arrow, int, 1, "arrow style of the best angle indicator; \"0\" = none, \"1\" = top, \"2\" = bottom, \"3\" = both");
AUTOCVAR_SAVE(hud_panel_strafehud_bestangle_arrow_size, float, 0.5, "arrow size of the best angle indicator (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_switch, int, 1, "\"1\" = enable the strafe angle indicator showing the angle to move to when changing side, \"2\" = show the normal switch indicators when W-turning, \"3\" = also while side strafing");
AUTOCVAR_SAVE(hud_panel_strafehud_switch_minspeed, float, -1, "minimum speed in qu/s at which angle indicator(s) which are used to aid changing strafe direction will be shown; \"-1\" = dynamic");
AUTOCVAR_SAVE(hud_panel_strafehud_switch_color, vector, '1 1 0', "color of the strafe angle indicators for changing strafe direction");
AUTOCVAR_SAVE(hud_panel_strafehud_switch_alpha, float, 0.5, "opacity of the strafe angle indicators for changing strafe direction");
AUTOCVAR_SAVE(hud_panel_strafehud_switch_line, int, 0, "defines the number of dashes of the change angle indicator line; \"0\" = no line, \"1\" = solid line");
AUTOCVAR_SAVE(hud_panel_strafehud_switch_line_width, float, 0.001, "width of the change angle indicator line (relative to the panel width)");
AUTOCVAR_SAVE(hud_panel_strafehud_switch_line_height, float, 1, "height of the change angle indicator line (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_switch_arrow, int, 1, "arrow style of the change angle indicator; \"0\" = none, \"1\" = top, \"2\" = bottom, \"3\" = both");
AUTOCVAR_SAVE(hud_panel_strafehud_switch_arrow_size, float, 0.5, "arrow size of the change angle indicator (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn, int, 1, "enable W-turn indicators showing the angle to rotate your velocity as fast as possible; \"1\" = only if W-turning, \"2\" = also while strafing normally, \"3\" = also while side strafing");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_color, vector, '0 0 1', "color of the W-turn indicators");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_alpha, float, 0.5, "opacity of the W-turn indicators");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_proper, bool, false, "use the proper formula to calculate W-turn indicators (WARNING: loses accuracy at high speeds)");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_unrestricted, bool, false, "enable W-turn indicators even when W-turning gives acceleration (WARNING: not completely accurate)");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_line, int, 0, "defines the number of dashes of the W-turn angle indicator line; \"0\" = no line, \"1\" = solid line");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_line_width, float, 0.001, "width of the W-turn angle indicator line (relative to the panel width)");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_line_height, float, 1, "height of the W-turn angle indicator line (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_arrow, int, 1, "arrow style of the W-turn angle indicator; \"0\" = none, \"1\" = top, \"2\" = bottom, \"3\" = both");
AUTOCVAR_SAVE(hud_panel_strafehud_wturn_arrow_size, float, 0.5, "arrow size of the W-turn angle indicator (relative to the panel height)");

AUTOCVAR_SAVE(hud_panel_strafehud_direction, bool, false, "enable direction caps to see in which direction you are currently strafing");
AUTOCVAR_SAVE(hud_panel_strafehud_direction_color, vector, '0 0.5 1', "color of the direction caps which indicate the direction the player is currently strafing towards");
AUTOCVAR_SAVE(hud_panel_strafehud_direction_alpha, float, 1, "opacity of the direction caps which indicate the direction the player is currently strafing towards");
AUTOCVAR_SAVE(hud_panel_strafehud_direction_width, float, 0.25, "stroke width of the direction caps which indicate the direction the player is currently strafing towards (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_direction_length, float, 0.02, "length of the horizontal component of the direction caps which indicate the direction the player is currently strafing towards (relative to the panel width)");

AUTOCVAR_SAVE(hud_panel_strafehud_slickdetector, bool, true, "enable the slick detector which notifies you if there is slick near you");
AUTOCVAR_SAVE(hud_panel_strafehud_slickdetector_range, float, 200, "range of the slick detector (in qu)");
AUTOCVAR_SAVE(hud_panel_strafehud_slickdetector_granularity, int, 1, "value from 0 to 4 which defines how exact the search for slick should be, higher values may yield better results but require more computation");
AUTOCVAR_SAVE(hud_panel_strafehud_slickdetector_color, vector, '0 1 1', "color of the slick detector indicator");
AUTOCVAR_SAVE(hud_panel_strafehud_slickdetector_alpha, float, 0.5, "opacity of the slick detector indicator");
AUTOCVAR_SAVE(hud_panel_strafehud_slickdetector_height, float, 0.125, "height of the slick detector indicator (relative to the panel height)");

AUTOCVAR_SAVE(hud_panel_strafehud_startspeed, bool, true, "enable the start speed indicator which shows you the speed you had while passing the start trigger of a race map");
AUTOCVAR_SAVE(hud_panel_strafehud_startspeed_fade, float, 4, "fade time (in seconds) of the start speed text");
AUTOCVAR_SAVE(hud_panel_strafehud_startspeed_color, vector, '1 0.75 0', "color of the start speed text");
AUTOCVAR_SAVE(hud_panel_strafehud_startspeed_pos, vector, '0 -1 0', "position of the start speed text (relative to the panel), the Y coordinate must be <= -1 (below) or >= 1 (above) the panel");
AUTOCVAR_SAVE(hud_panel_strafehud_startspeed_size, float, 1.5, "size of the start speed text (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_jumpheight, bool, false, "enable the jump height indicator which tells you how high you jumped");
AUTOCVAR_SAVE(hud_panel_strafehud_jumpheight_fade, float, 4, "fade time (in seconds) of the jump height text");
AUTOCVAR_SAVE(hud_panel_strafehud_jumpheight_min, float, 50, "minimum jump height to display in the selected unit");
AUTOCVAR_SAVE(hud_panel_strafehud_jumpheight_color, vector, '0 1 0.75', "color of the jump height text");
AUTOCVAR_SAVE(hud_panel_strafehud_jumpheight_pos, vector, '0 -2 0', "position of the jump height text (relative to the panel), the Y coordinate must be <= -1 (below) or >= 1 (above) the panel");
AUTOCVAR_SAVE(hud_panel_strafehud_jumpheight_size, float, 1.5, "size of the jump height text (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_vangle, bool, false, "\"1\" = enable the vertical angle indicator");
AUTOCVAR_SAVE(hud_panel_strafehud_vangle_color, vector, '0.75 0.75 0.75', "color of the vertical angle text");
AUTOCVAR_SAVE(hud_panel_strafehud_vangle_pos, vector, '-0.25 1 0', "position of the vertical angle text (relative to the panel), the Y coordinate must be <= -1 (below) or >= 1 (above) the panel");
AUTOCVAR_SAVE(hud_panel_strafehud_vangle_size, float, 1, "size of the vertical angle text (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_strafeefficiency, bool, false, "\"1\" = enable the strafe efficiency indicator");
AUTOCVAR_SAVE(hud_panel_strafehud_strafeefficiency_pos, vector, '0.25 1 0', "position of the strafe efficiency text (relative to the panel), the Y coordinate must be <= -1 (below) or >= 1 (above) the panel");
AUTOCVAR_SAVE(hud_panel_strafehud_strafeefficiency_size, float, 1, "size of the strafe efficiency text (relative to the panel height)");
AUTOCVAR_SAVE(hud_panel_strafehud_projection, int, 0, "StrafeHUD projection mode; \"0\" = linear, \"1\" = perspective, \"2\" = panoramic");

AUTOCVAR_SAVE(hud_panel_strafehud_sonar, bool, false, "\"1\" = enable the strafe sonar");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_audio, string, "misc/talk", "audio to play for sonar");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_start, float, 0.5, "how optimal from 0 to 1 your strafing angle has to be for the strafe sonar to activate");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_interval_start, float, 0.333333, "strafe sonar sound interval in seconds");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_interval_range, float, -0.222222, "dynamic sound interval range in seconds of the strafe sonar as you approach the optimal angle");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_interval_exponent, float, 1, "exponent of the dynamic sound interval range of the strafe sonar");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_volume_start, float, 0.333333, "sound volume of the strafe sonar");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_volume_range, float, 0.666666, "dynamic volume range of the strafe sonar as you approach the optimal angle");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_volume_exponent, float, 1, "exponent of the dynamic volume range of the strafe sonar");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_pitch_start, float, 0.9, "playback speed of the strafe sonar");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_pitch_range, float, 0.1, "dynamic playback speed range of the strafe sonar as you approach the optimal angle");
AUTOCVAR_SAVE(hud_panel_strafehud_sonar_pitch_exponent, float, 1, "exponent of the dynamic playback speed range of the strafe sonar");

const int STRAFEHUD_MODE_VIEW_CENTERED      = 0;
const int STRAFEHUD_MODE_VELOCITY_CENTERED  = 1;

const int STRAFEHUD_ONGROUND_OVERTURN  = 0;
const int STRAFEHUD_ONGROUND_GROUND    = 1;
const int STRAFEHUD_ONGROUND_AIR       = 2;

const int STRAFEHUD_DIRECTION_NONE   = 0;
const int STRAFEHUD_DIRECTION_LEFT   = 1;
const int STRAFEHUD_DIRECTION_RIGHT  = 2;

const int STRAFEHUD_SWITCH_NONE        = 0;
const int STRAFEHUD_SWITCH_ACTUAL      = 1;
const int STRAFEHUD_SWITCH_NORMAL      = 2;
const int STRAFEHUD_SWITCH_SIDESTRAFE  = 3;

const int STRAFEHUD_WTURN_NONE        = 0;
const int STRAFEHUD_WTURN_ONLY        = 1;
const int STRAFEHUD_WTURN_NORMAL      = 2;
const int STRAFEHUD_WTURN_SIDESTRAFE  = 3;

const int STRAFEHUD_KEYS_NONE      = 0;
const int STRAFEHUD_KEYS_FORWARD   = 1;
const int STRAFEHUD_KEYS_BACKWARD  = 2;

const int STRAFEHUD_STYLE_DRAWFILL       = 0;
const int STRAFEHUD_STYLE_PROGRESSBAR    = 1;
const int STRAFEHUD_STYLE_GRADIENT       = 2;
const int STRAFEHUD_STYLE_SOFT_GRADIENT  = 3;

const int STRAFEHUD_GRADIENT_NONE   = 0;
const int STRAFEHUD_GRADIENT_LEFT   = 1;
const int STRAFEHUD_GRADIENT_RIGHT  = 2;
const int STRAFEHUD_GRADIENT_BOTH   = 3;

const int STRAFEHUD_PROJECTION_LINEAR       = 0;
const int STRAFEHUD_PROJECTION_PERSPECTIVE  = 1;
const int STRAFEHUD_PROJECTION_PANORAMIC    = 2;

const float ACOS_SQRT2_3_DEG = 35.2643896827546543153;  /* acos(sqrt(2/3)) * RAD2DEG */
