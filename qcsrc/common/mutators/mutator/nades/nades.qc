#include "nades.qh"

#ifdef IMPLEMENTATION

#ifdef SVQC
bool autocvar_g_nades_nade_small;
float autocvar_g_nades_spread = 0.04;
#endif

REGISTER_STAT(NADES_SMALL, int, autocvar_g_nades_nade_small)

#ifndef MENUQC
entity Nade_TrailEffect(int proj, int nade_team)
{
    switch (proj)
    {
        case PROJECTILE_NADE:       return EFFECT_NADE_TRAIL(nade_team);
        case PROJECTILE_NADE_BURN:  return EFFECT_NADE_TRAIL_BURN(nade_team);
    }

    FOREACH(Nades, true, LAMBDA(
        for (int j = 0; j < 2; j++)
        {
            if (it.m_projectile[j] == proj)
            {
                string trail = it.m_trail[j].eent_eff_name;
                if (trail) return it.m_trail[j];
                break;
            }
        }
    ));

    return EFFECT_Null;
}
#endif

#ifdef CSQC
REGISTER_MUTATOR(cl_nades, true);
MUTATOR_HOOKFUNCTION(cl_nades, HUD_Draw_overlay)
{
	if (STAT(HEALING_ORB) <= time) return false;
	MUTATOR_ARGV(0, vector) = NADE_TYPE_HEAL.m_color;
	MUTATOR_ARGV(0, float) = STAT(HEALING_ORB_ALPHA);
	return true;
}
MUTATOR_HOOKFUNCTION(cl_nades, Ent_Projectile)
{
    SELFPARAM();
	if (self.cnt == PROJECTILE_NAPALM_FOUNTAIN)
	{
		self.modelindex = 0;
		self.traileffect = EFFECT_FIREBALL.m_id;
		return true;
	}
	if (Nade_FromProjectile(self.cnt) != NADE_TYPE_Null)
	{
		setmodel(self, MDL_PROJECTILE_NADE);
		entity trail = Nade_TrailEffect(self.cnt, self.team);
		if (trail.eent_eff_name) self.traileffect = trail.m_id;
		return true;
	}
}
MUTATOR_HOOKFUNCTION(cl_nades, EditProjectile)
{
    SELFPARAM();
	if (self.cnt == PROJECTILE_NAPALM_FOUNTAIN)
	{
		loopsound(self, CH_SHOTS_SINGLE, SND(FIREBALL_FLY2), VOL_BASE, ATTEN_NORM);
		self.mins = '-16 -16 -16';
		self.maxs = '16 16 16';
	}

	entity nade_type = Nade_FromProjectile(self.cnt);
	if (nade_type == NADE_TYPE_Null) return;
	if(STAT(NADES_SMALL, NULL))
	{
		self.mins = '-8 -8 -8';
		self.maxs = '8 8 8';
	}
	else
	{
		self.mins = '-16 -16 -16';
		self.maxs = '16 16 16';
	}
	self.colormod = nade_type.m_color;
	self.move_movetype = MOVETYPE_BOUNCE;
	self.move_touch = func_null;
	self.scale = 1.5;
	self.avelocity = randomvec() * 720;

	if (nade_type == NADE_TYPE_TRANSLOCATE || nade_type == NADE_TYPE_SPAWN)
		self.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_PLAYERCLIP | DPCONTENTS_BOTCLIP;
	else
		self.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_BODY;
}
bool Projectile_isnade(int p)
{
	return Nade_FromProjectile(p) != NADE_TYPE_Null;
}
void DrawAmmoNades(vector myPos, vector mySize, bool draw_expanding, float expand_time)
{
	float bonusNades    = STAT(NADE_BONUS);
	float bonusProgress = STAT(NADE_BONUS_SCORE);
	float bonusType     = STAT(NADE_BONUS_TYPE);
	Nade def = Nades_from(bonusType);
	vector nadeColor    = def.m_color;
	string nadeIcon     = def.m_icon;

	vector iconPos, textPos;

	if(autocvar_hud_panel_ammo_iconalign)
	{
		iconPos = myPos + eX * 2 * mySize.y;
		textPos = myPos;
	}
	else
	{
		iconPos = myPos;
		textPos = myPos + eX * mySize.y;
	}

	if(bonusNades > 0 || bonusProgress > 0)
	{
		DrawNadeProgressBar(myPos, mySize, bonusProgress, nadeColor);

		if(autocvar_hud_panel_ammo_text)
			drawstring_aspect(textPos, ftos(bonusNades), eX * (2/3) * mySize.x + eY * mySize.y, '1 1 1', panel_fg_alpha, DRAWFLAG_NORMAL);

		if(draw_expanding)
			drawpic_aspect_skin_expanding(iconPos, nadeIcon, '1 1 0' * mySize.y, '1 1 1', panel_fg_alpha, DRAWFLAG_NORMAL, expand_time);

		drawpic_aspect_skin(iconPos, nadeIcon, '1 1 0' * mySize.y, '1 1 1', panel_fg_alpha, DRAWFLAG_NORMAL);
	}
}
#endif

#ifdef SVQC

#include <common/gamemodes/all.qh>
#include <common/monsters/spawn.qh>
#include <common/monsters/sv_monsters.qh>
#include <server/g_subs.qh>

REGISTER_MUTATOR(nades, cvar("g_nades"));

.float nade_time_primed;

.entity nade_spawnloc;

void nade_timer_think()
{SELFPARAM();
	self.skin = 8 - (self.owner.wait - time) / (autocvar_g_nades_nade_lifetime / 10);
	self.nextthink = time;
	if(!self.owner || wasfreed(self.owner))
		remove(self);
}

void nade_burn_spawn(entity _nade)
{
	CSQCProjectile(_nade, true, Nades_from(_nade.nade_type).m_projectile[true], true);
}

void nade_spawn(entity _nade)
{
	entity timer = new(nade_timer);
	setmodel(timer, MDL_NADE_TIMER);
	setattachment(timer, _nade, "");
	timer.colormap = _nade.colormap;
	timer.glowmod = _nade.glowmod;
	timer.think = nade_timer_think;
	timer.nextthink = time;
	timer.wait = _nade.wait;
	timer.owner = _nade;
	timer.skin = 10;

	_nade.effects |= EF_LOWPRECISION;

	CSQCProjectile(_nade, true, Nades_from(_nade.nade_type).m_projectile[false], true);
}

void napalm_damage(float dist, float damage, float edgedamage, float burntime)
{SELFPARAM();
	entity e;
	float d;
	vector p;

	if ( damage < 0 )
		return;

	RandomSelection_Init();
	for(e = WarpZone_FindRadius(self.origin, dist, true); e; e = e.chain)
		if(e.takedamage == DAMAGE_AIM)
		if(self.realowner != e || autocvar_g_nades_napalm_selfdamage)
		if(!IS_PLAYER(e) || !self.realowner || DIFF_TEAM(e, self))
		if(!STAT(FROZEN, e))
		{
			p = e.origin;
			p.x += e.mins.x + random() * (e.maxs.x - e.mins.x);
			p.y += e.mins.y + random() * (e.maxs.y - e.mins.y);
			p.z += e.mins.z + random() * (e.maxs.z - e.mins.z);
			d = vlen(WarpZone_UnTransformOrigin(e, self.origin) - p);
			if(d < dist)
			{
				e.fireball_impactvec = p;
				RandomSelection_Add(e, 0, string_null, 1 / (1 + d), !Fire_IsBurning(e));
			}
		}
	if(RandomSelection_chosen_ent)
	{
		d = vlen(WarpZone_UnTransformOrigin(RandomSelection_chosen_ent, self.origin) - RandomSelection_chosen_ent.fireball_impactvec);
		d = damage + (edgedamage - damage) * (d / dist);
		Fire_AddDamage(RandomSelection_chosen_ent, self.realowner, d * burntime, burntime, self.projectiledeathtype | HITTYPE_BOUNCE);
		//trailparticles(self, particleeffectnum(EFFECT_FIREBALL_LASER), self.origin, RandomSelection_chosen_ent.fireball_impactvec);
		Send_Effect(EFFECT_FIREBALL_LASER, self.origin, RandomSelection_chosen_ent.fireball_impactvec - self.origin, 1);
	}
}


void napalm_ball_think()
{SELFPARAM();
	if(round_handler_IsActive())
	if(!round_handler_IsRoundStarted())
	{
		remove(self);
		return;
	}

	if(time > self.pushltime)
	{
		remove(self);
		return;
	}

	vector midpoint = ((self.absmin + self.absmax) * 0.5);
	if(pointcontents(midpoint) == CONTENT_WATER)
	{
		self.velocity = self.velocity * 0.5;

		if(pointcontents(midpoint + '0 0 16') == CONTENT_WATER)
			{ self.velocity_z = 200; }
	}

	self.angles = vectoangles(self.velocity);

	napalm_damage(autocvar_g_nades_napalm_ball_radius,autocvar_g_nades_napalm_ball_damage,
				  autocvar_g_nades_napalm_ball_damage,autocvar_g_nades_napalm_burntime);

	self.nextthink = time + 0.1;
}


void nade_napalm_ball()
{SELFPARAM();
	entity proj;
	vector kick;

	spamsound(self, CH_SHOTS, SND(FIREBALL_FIRE), VOL_BASE, ATTEN_NORM);

	proj = new(grenade);
	proj.owner = self.owner;
	proj.realowner = self.realowner;
	proj.team = self.owner.team;
	proj.bot_dodge = true;
	proj.bot_dodgerating = autocvar_g_nades_napalm_ball_damage;
	proj.movetype = MOVETYPE_BOUNCE;
	proj.projectiledeathtype = DEATH_NADE_NAPALM.m_id;
	PROJECTILE_MAKETRIGGER(proj);
	setmodel(proj, MDL_Null);
	proj.scale = 1;//0.5;
	setsize(proj, '-4 -4 -4', '4 4 4');
	setorigin(proj, self.origin);
	proj.think = napalm_ball_think;
	proj.nextthink = time;
	proj.damageforcescale = autocvar_g_nades_napalm_ball_damageforcescale;
	proj.effects = EF_LOWPRECISION | EF_FLAME;

	kick.x =(random() - 0.5) * 2 * autocvar_g_nades_napalm_ball_spread;
	kick.y = (random() - 0.5) * 2 * autocvar_g_nades_napalm_ball_spread;
	kick.z = (random()/2+0.5) * autocvar_g_nades_napalm_ball_spread;
	proj.velocity = kick;

	proj.pushltime = time + autocvar_g_nades_napalm_ball_lifetime;

	proj.angles = vectoangles(proj.velocity);
	proj.flags = FL_PROJECTILE;
	proj.missile_flags = MIF_SPLASH | MIF_PROXY | MIF_ARC;

	//CSQCProjectile(proj, true, PROJECTILE_NAPALM_FIRE, true);
}


void napalm_fountain_think()
{SELFPARAM();

	if(round_handler_IsActive())
	if(!round_handler_IsRoundStarted())
	{
		remove(self);
		return;
	}

	if(time >= self.ltime)
	{
		remove(self);
		return;
	}

	vector midpoint = ((self.absmin + self.absmax) * 0.5);
	if(pointcontents(midpoint) == CONTENT_WATER)
	{
		self.velocity = self.velocity * 0.5;

		if(pointcontents(midpoint + '0 0 16') == CONTENT_WATER)
			{ self.velocity_z = 200; }

		UpdateCSQCProjectile(self);
	}

	napalm_damage(autocvar_g_nades_napalm_fountain_radius, autocvar_g_nades_napalm_fountain_damage,
		autocvar_g_nades_napalm_fountain_edgedamage, autocvar_g_nades_napalm_burntime);

	self.nextthink = time + 0.1;
	if(time >= self.nade_special_time)
	{
		self.nade_special_time = time + autocvar_g_nades_napalm_fountain_delay;
		nade_napalm_ball();
	}
}

void nade_napalm_boom()
{SELFPARAM();
	entity fountain;
	int c;
	for (c = 0; c < autocvar_g_nades_napalm_ball_count; c++)
		nade_napalm_ball();


	fountain = spawn();
	fountain.owner = self.owner;
	fountain.realowner = self.realowner;
	fountain.origin = self.origin;
	setorigin(fountain, fountain.origin);
	fountain.think = napalm_fountain_think;
	fountain.nextthink = time;
	fountain.ltime = time + autocvar_g_nades_napalm_fountain_lifetime;
	fountain.pushltime = fountain.ltime;
	fountain.team = self.team;
	fountain.movetype = MOVETYPE_TOSS;
	fountain.projectiledeathtype = DEATH_NADE_NAPALM.m_id;
	fountain.bot_dodge = true;
	fountain.bot_dodgerating = autocvar_g_nades_napalm_fountain_damage;
	fountain.nade_special_time = time;
	setsize(fountain, '-16 -16 -16', '16 16 16');
	CSQCProjectile(fountain, true, PROJECTILE_NAPALM_FOUNTAIN, true);
}

void nade_ice_freeze(entity freezefield, entity frost_target, float freeze_time)
{
	frost_target.frozen_by = freezefield.realowner;
	Send_Effect(EFFECT_ELECTRO_IMPACT, frost_target.origin, '0 0 0', 1);
	Freeze(frost_target, 1/freeze_time, 3, false);

	Drop_Special_Items(frost_target);
}

void nade_ice_think()
{SELFPARAM();

	if(round_handler_IsActive())
	if(!round_handler_IsRoundStarted())
	{
		remove(self);
		return;
	}

	if(time >= self.ltime)
	{
		if ( autocvar_g_nades_ice_explode )
		{
			entity expef = EFFECT_NADE_EXPLODE(self.realowner.team);
			Send_Effect(expef, self.origin + '0 0 1', '0 0 0', 1);
			sound(self, CH_SHOTS, SND_ROCKET_IMPACT, VOL_BASE, ATTEN_NORM);

			RadiusDamage(self, self.realowner, autocvar_g_nades_nade_damage, autocvar_g_nades_nade_edgedamage,
				autocvar_g_nades_nade_radius, self, world, autocvar_g_nades_nade_force, self.projectiledeathtype, self.enemy);
			Damage_DamageInfo(self.origin, autocvar_g_nades_nade_damage, autocvar_g_nades_nade_edgedamage,
				autocvar_g_nades_nade_radius, '1 1 1' * autocvar_g_nades_nade_force, self.projectiledeathtype, 0, self);
		}
		remove(self);
		return;
	}


	self.nextthink = time+0.1;

	// gaussian
	float randomr;
	randomr = random();
	randomr = exp(-5*randomr*randomr)*autocvar_g_nades_nade_radius;
	float randomw;
	randomw = random()*M_PI*2;
	vector randomp;
	randomp.x = randomr*cos(randomw);
	randomp.y = randomr*sin(randomw);
	randomp.z = 1;
	Send_Effect(EFFECT_ELECTRO_MUZZLEFLASH, self.origin + randomp, '0 0 0', 1);

	if(time >= self.nade_special_time)
	{
		self.nade_special_time = time+0.7;

		Send_Effect(EFFECT_ELECTRO_IMPACT, self.origin, '0 0 0', 1);
		Send_Effect(EFFECT_ICEFIELD, self.origin, '0 0 0', 1);
	}


	float current_freeze_time = self.ltime - time - 0.1;

	entity e;
	for(e = findradius(self.origin, autocvar_g_nades_nade_radius); e; e = e.chain)
	if(e != self)
	if(!autocvar_g_nades_ice_teamcheck || (DIFF_TEAM(e, self.realowner) || e == self.realowner))
	if(e.takedamage && !IS_DEAD(e))
	if(e.health > 0)
	if(!e.revival_time || ((time - e.revival_time) >= 1.5))
	if(!STAT(FROZEN, e))
	if(current_freeze_time > 0)
		nade_ice_freeze(self, e, current_freeze_time);
}

void nade_ice_boom()
{SELFPARAM();
	entity fountain;
	fountain = spawn();
	fountain.owner = self.owner;
	fountain.realowner = self.realowner;
	fountain.origin = self.origin;
	setorigin(fountain, fountain.origin);
	fountain.think = nade_ice_think;
	fountain.nextthink = time;
	fountain.ltime = time + autocvar_g_nades_ice_freeze_time;
	fountain.pushltime = fountain.wait = fountain.ltime;
	fountain.team = self.team;
	fountain.movetype = MOVETYPE_TOSS;
	fountain.projectiledeathtype = DEATH_NADE_ICE.m_id;
	fountain.bot_dodge = false;
	setsize(fountain, '-16 -16 -16', '16 16 16');
	fountain.nade_special_time = time+0.3;
	fountain.angles = self.angles;

	if ( autocvar_g_nades_ice_explode )
	{
		setmodel(fountain, MDL_PROJECTILE_GRENADE);
		entity timer = new(nade_timer);
		setmodel(timer, MDL_NADE_TIMER);
		setattachment(timer, fountain, "");
		timer.colormap = self.colormap;
		timer.glowmod = self.glowmod;
		timer.think = nade_timer_think;
		timer.nextthink = time;
		timer.wait = fountain.ltime;
		timer.owner = fountain;
		timer.skin = 10;
	}
	else
		setmodel(fountain, MDL_Null);
}

void nade_translocate_boom()
{SELFPARAM();
	if(self.realowner.vehicle)
		return;

	vector locout = self.origin + '0 0 1' * (1 - self.realowner.mins.z - 24);
	tracebox(locout, self.realowner.mins, self.realowner.maxs, locout, MOVE_NOMONSTERS, self.realowner);
	locout = trace_endpos;

	makevectors(self.realowner.angles);

	MUTATOR_CALLHOOK(PortalTeleport, self.realowner);

	TeleportPlayer(self, self.realowner, locout, self.realowner.angles, v_forward * vlen(self.realowner.velocity), '0 0 0', '0 0 0', TELEPORT_FLAGS_TELEPORTER);
}

void nade_spawn_boom()
{SELFPARAM();
	entity spawnloc = spawn();
	setorigin(spawnloc, self.origin);
	setsize(spawnloc, self.realowner.mins, self.realowner.maxs);
	spawnloc.movetype = MOVETYPE_NONE;
	spawnloc.solid = SOLID_NOT;
	spawnloc.drawonlytoclient = self.realowner;
	spawnloc.effects = EF_STARDUST;
	spawnloc.cnt = autocvar_g_nades_spawn_count;

	if(self.realowner.nade_spawnloc)
	{
		remove(self.realowner.nade_spawnloc);
		self.realowner.nade_spawnloc = world;
	}

	self.realowner.nade_spawnloc = spawnloc;
}

void nade_heal_think()
{SELFPARAM();
	if(time >= self.ltime)
	{
		remove(self);
		return;
	}

	self.nextthink = time;

	if(time >= self.nade_special_time)
	{
		self.nade_special_time = time+0.25;
		self.nade_show_particles = 1;
	}
	else
		self.nade_show_particles = 0;
}

void nade_heal_touch()
{SELFPARAM();
	float maxhealth;
	float health_factor;
	if(IS_PLAYER(other) || IS_MONSTER(other))
	if(!IS_DEAD(other))
	if(!STAT(FROZEN, other))
	{
		health_factor = autocvar_g_nades_heal_rate*frametime/2;
		if ( other != self.realowner )
		{
			if ( SAME_TEAM(other,self) )
				health_factor *= autocvar_g_nades_heal_friend;
			else
				health_factor *= autocvar_g_nades_heal_foe;
		}
		if ( health_factor > 0 )
		{
			maxhealth = (IS_MONSTER(other)) ? other.max_health : g_pickup_healthmega_max;
			if ( other.health < maxhealth )
			{
				if ( self.nade_show_particles )
					Send_Effect(EFFECT_HEALING, other.origin, '0 0 0', 1);
				other.health = min(other.health+health_factor, maxhealth);
			}
			other.pauserothealth_finished = max(other.pauserothealth_finished, time + autocvar_g_balance_pause_health_rot);
		}
		else if ( health_factor < 0 )
		{
			Damage(other,self,self.realowner,-health_factor,DEATH_NADE_HEAL.m_id,other.origin,'0 0 0');
		}

	}

	if ( IS_REAL_CLIENT(other) || IS_VEHICLE(other) )
	{
		entity show_red = (IS_VEHICLE(other)) ? other.owner : other;
		show_red.stat_healing_orb = time+0.1;
		show_red.stat_healing_orb_alpha = 0.75 * (self.ltime - time) / self.healer_lifetime;
	}
}

void nade_heal_boom()
{SELFPARAM();
	entity healer;
	healer = spawn();
	healer.owner = self.owner;
	healer.realowner = self.realowner;
	setorigin(healer, self.origin);
	healer.healer_lifetime = autocvar_g_nades_heal_time; // save the cvar
	healer.ltime = time + healer.healer_lifetime;
	healer.team = self.realowner.team;
	healer.bot_dodge = false;
	healer.solid = SOLID_TRIGGER;
	healer.touch = nade_heal_touch;

	setmodel(healer, MDL_NADE_HEAL);
	healer.healer_radius = autocvar_g_nades_nade_radius;
	vector size = '1 1 1' * healer.healer_radius / 2;
	setsize(healer,-size,size);

	Net_LinkEntity(healer, true, 0, healer_send);

	healer.think = nade_heal_think;
	healer.nextthink = time;
	healer.SendFlags |= 1;
}

void nade_monster_boom()
{SELFPARAM();
	entity e = spawnmonster(self.pokenade_type, 0, self.realowner, self.realowner, self.origin, false, false, 1);

	if(autocvar_g_nades_pokenade_monster_lifetime > 0)
		e.monster_lifetime = time + autocvar_g_nades_pokenade_monster_lifetime;
	e.monster_skill = MONSTER_SKILL_INSANE;
}

void nade_boom()
{SELFPARAM();
	entity expef = NULL;
	bool nade_blast = true;

	switch ( Nades_from(self.nade_type) )
	{
		case NADE_TYPE_NAPALM:
			nade_blast = autocvar_g_nades_napalm_blast;
			expef = EFFECT_EXPLOSION_MEDIUM;
			break;
		case NADE_TYPE_ICE:
			nade_blast = false;
			expef = EFFECT_ELECTRO_COMBO; // hookbomb_explode electro_combo bigplasma_impact
			break;
		case NADE_TYPE_TRANSLOCATE:
			nade_blast = false;
			break;
		case NADE_TYPE_MONSTER:
		case NADE_TYPE_SPAWN:
			nade_blast = false;
			switch(self.realowner.team)
			{
				case NUM_TEAM_1: expef = EFFECT_SPAWN_RED; break;
				case NUM_TEAM_2: expef = EFFECT_SPAWN_BLUE; break;
				case NUM_TEAM_3: expef = EFFECT_SPAWN_YELLOW; break;
				case NUM_TEAM_4: expef = EFFECT_SPAWN_PINK; break;
				default: expef = EFFECT_SPAWN_NEUTRAL; break;
			}
			break;
		case NADE_TYPE_HEAL:
			nade_blast = false;
			expef = EFFECT_SPAWN_RED;
			break;

		default:
		case NADE_TYPE_NORMAL:
			expef = EFFECT_NADE_EXPLODE(self.realowner.team);
			break;
	}

	if(expef)
		Send_Effect(expef, findbetterlocation(self.origin, 8), '0 0 0', 1);

	sound(self, CH_SHOTS_SINGLE, SND_Null, VOL_BASE, ATTEN_NORM);
	sound(self, CH_SHOTS, SND_ROCKET_IMPACT, VOL_BASE, ATTEN_NORM);

	self.event_damage = func_null; // prevent somehow calling damage in the next call

	if(nade_blast)
	{
		RadiusDamage(self, self.realowner, autocvar_g_nades_nade_damage, autocvar_g_nades_nade_edgedamage,
				 autocvar_g_nades_nade_radius, self, world, autocvar_g_nades_nade_force, self.projectiledeathtype, self.enemy);
		Damage_DamageInfo(self.origin, autocvar_g_nades_nade_damage, autocvar_g_nades_nade_edgedamage, autocvar_g_nades_nade_radius, '1 1 1' * autocvar_g_nades_nade_force, self.projectiledeathtype, 0, self);
	}

	if(self.takedamage)
	switch ( Nades_from(self.nade_type) )
	{
		case NADE_TYPE_NAPALM: nade_napalm_boom(); break;
		case NADE_TYPE_ICE: nade_ice_boom(); break;
		case NADE_TYPE_TRANSLOCATE: nade_translocate_boom(); break;
		case NADE_TYPE_SPAWN: nade_spawn_boom(); break;
		case NADE_TYPE_HEAL: nade_heal_boom(); break;
		case NADE_TYPE_MONSTER: nade_monster_boom(); break;
	}

	FOREACH_ENTITY_ENT(aiment, self,
	{
		if(it.classname == "grapplinghook")
			RemoveGrapplingHook(it.realowner);
	});

	remove(self);
}

void spawn_held_nade(entity player, entity nowner, float ntime, int ntype, string pntype);
void nade_pickup(entity this, entity thenade)
{
	spawn_held_nade(this, thenade.realowner, autocvar_g_nades_pickup_time, thenade.nade_type, thenade.pokenade_type);

	// set refire so player can't even
	this.nade_refire = time + autocvar_g_nades_nade_refire;
	this.nade_timer = 0;

	if(this.nade)
		this.nade.nade_time_primed = thenade.nade_time_primed;
}

bool CanThrowNade(entity this);
void nade_touch()
{SELFPARAM();
	if(other)
		UpdateCSQCProjectile(self);

	if(other == self.realowner)
		return; // no self impacts

	if(autocvar_g_nades_pickup)
	if(time >= self.spawnshieldtime)
	if(!other.nade && self.health == self.max_health) // no boosted shot pickups, thank you very much
	if(!other.frozen)
	if(CanThrowNade(other)) // prevent some obvious things, like dead players
	if(IS_REAL_CLIENT(other)) // above checks for IS_PLAYER, don't need to do it here
	{
		nade_pickup(other, self);
		sound(self, CH_SHOTS_SINGLE, SND_Null, VOL_BASE, 0.5 *(ATTEN_LARGE + ATTEN_MAX));
		remove(self);
		return;
	}
	/*float is_weapclip = 0;
	if(trace_dphitq3surfaceflags & Q3SURFACEFLAG_NODRAW)
	if (!(trace_dphitq3surfaceflags & Q3SURFACEFLAG_NONSOLID))
	if (!(trace_dphitcontents & DPCONTENTS_OPAQUE))
		is_weapclip = 1;*/
	if(ITEM_TOUCH_NEEDKILL()) // || is_weapclip)
	{
		FOREACH_ENTITY_ENT(aiment, self,
		{
			if(it.classname == "grapplinghook")
				RemoveGrapplingHook(it.realowner);
		});
		remove(self);
		return;
	}

	PROJECTILE_TOUCH;

	//setsize(self, '-2 -2 -2', '2 2 2');
	//UpdateCSQCProjectile(self);
	if(self.health == self.max_health)
	{
		spamsound(self, CH_SHOTS, SND(GRENADE_BOUNCE_RANDOM()), VOL_BASE, ATTEN_NORM);
		return;
	}

	self.enemy = other;
	nade_boom();
}

void nade_beep()
{SELFPARAM();
	sound(self, CH_SHOTS_SINGLE, SND_NADE_BEEP, VOL_BASE, 0.5 *(ATTEN_LARGE + ATTEN_MAX));
	self.think = nade_boom;
	self.nextthink = max(self.wait, time);
}

void nade_damage(entity this, entity inflictor, entity attacker, float damage, int deathtype, vector hitloc, vector force)
{
	if(ITEM_DAMAGE_NEEDKILL(deathtype))
	{
		this.takedamage = DAMAGE_NO;
		WITHSELF(this, nade_boom());
		return;
	}

	if(this.nade_type == NADE_TYPE_TRANSLOCATE.m_id || this.nade_type == NADE_TYPE_SPAWN.m_id)
		return;

	if (MUTATOR_CALLHOOK(Nade_Damage, DEATH_WEAPONOF(deathtype), force, damage)) {}
	else if(DEATH_ISWEAPON(deathtype, WEP_BLASTER))
	{
		force *= 1.5;
		damage = 0;
	}
	else if(DEATH_ISWEAPON(deathtype, WEP_VAPORIZER) && (deathtype & HITTYPE_SECONDARY))
	{
		force *= 0.5; // too much
		damage = 0;
	}
	else if(DEATH_ISWEAPON(deathtype, WEP_VORTEX) || DEATH_ISWEAPON(deathtype, WEP_VAPORIZER))
	{
		force *= 6;
		damage = this.max_health * 0.55;
	}
	else if(DEATH_ISWEAPON(deathtype, WEP_MACHINEGUN))
		damage = this.max_health * 0.1;
	else if(DEATH_ISWEAPON(deathtype, WEP_SHOCKWAVE) || DEATH_ISWEAPON(deathtype, WEP_SHOTGUN)) // WEAPONTODO
	{
		if(deathtype & HITTYPE_SECONDARY)
		{
			damage = this.max_health * 0.1;
			force *= 10;
		}
		else
			damage = this.max_health * 1.15;
	}

	this.velocity += force;
	UpdateCSQCProjectile(this);

	if(damage <= 0 || ((IS_ONGROUND(this)) && IS_PLAYER(attacker)))
		return;

	if(this.health == this.max_health)
	{
		sound(this, CH_SHOTS_SINGLE, SND_Null, VOL_BASE, 0.5 *(ATTEN_LARGE + ATTEN_MAX));
		this.nextthink = max(time + autocvar_g_nades_nade_lifetime, time);
		this.think = nade_beep;
	}

	this.health -= damage;

	if ( this.nade_type != NADE_TYPE_HEAL.m_id || IS_PLAYER(attacker) )
		this.realowner = attacker;

	if(this.health <= 0)
		W_PrepareExplosionByDamage(this, attacker, nade_boom);
	else
		nade_burn_spawn(this);
}

void toss_nade(entity e, bool set_owner, vector _velocity, float _time)
{SELFPARAM();
	if(e.nade == world)
		return;

	entity _nade = e.nade;
	e.nade = world;

	remove(e.fake_nade);
	e.fake_nade = world;

	makevectors(e.v_angle);

	W_SetupShot(e, false, false, SND_Null, CH_WEAPON_A, 0);

	Kill_Notification(NOTIF_ONE_ONLY, e, MSG_CENTER, CPID_NADES);

	vector offset = (v_forward * autocvar_g_nades_throw_offset.x)
				  + (v_right * autocvar_g_nades_throw_offset.y)
				  + (v_up * autocvar_g_nades_throw_offset.z);
	if(autocvar_g_nades_throw_offset == '0 0 0')
		offset = '0 0 0';

	setorigin(_nade, w_shotorg + offset + (v_right * 25) * -1);
	//setmodel(_nade, MDL_PROJECTILE_NADE);
	//setattachment(_nade, world, "");
	PROJECTILE_MAKETRIGGER(_nade);
	if(STAT(NADES_SMALL, e))
		setsize(_nade, '-8 -8 -8', '8 8 8');
	else
		setsize(_nade, '-16 -16 -16', '16 16 16');
	_nade.movetype = MOVETYPE_BOUNCE;

	tracebox(_nade.origin, _nade.mins, _nade.maxs, _nade.origin, false, _nade);
	if (trace_startsolid)
		setorigin(_nade, e.origin);

	if(self.v_angle.x >= 70 && self.v_angle.x <= 110 && PHYS_INPUT_BUTTON_CROUCH(self))
		_nade.velocity = '0 0 100';
	else if(autocvar_g_nades_nade_newton_style == 1)
		_nade.velocity = e.velocity + _velocity;
	else if(autocvar_g_nades_nade_newton_style == 2)
		_nade.velocity = _velocity;
	else
		_nade.velocity = W_CalculateProjectileVelocity(e.velocity, _velocity, true);

	if(set_owner)
		_nade.realowner = e;

	_nade.touch = nade_touch;
	_nade.spawnshieldtime = time + 0.1; // prevent instantly picking up again
	_nade.health = autocvar_g_nades_nade_health;
	_nade.max_health = _nade.health;
	_nade.takedamage = DAMAGE_AIM;
	_nade.event_damage = nade_damage;
	_nade.customizeentityforclient = func_null;
	_nade.exteriormodeltoclient = world;
	_nade.traileffectnum = 0;
	_nade.teleportable = true;
	_nade.pushable = true;
	_nade.gravity = 1;
	_nade.missile_flags = MIF_SPLASH | MIF_ARC;
	_nade.damagedbycontents = true;
	_nade.angles = vectoangles(_nade.velocity);
	_nade.flags = FL_PROJECTILE;
	_nade.projectiledeathtype = DEATH_NADE.m_id;
	_nade.toss_time = time;
	_nade.solid = SOLID_CORPSE; //((_nade.nade_type == NADE_TYPE_TRANSLOCATE) ? SOLID_CORPSE : SOLID_BBOX);

	if(_nade.nade_type == NADE_TYPE_TRANSLOCATE.m_id || _nade.nade_type == NADE_TYPE_SPAWN.m_id)
		_nade.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_PLAYERCLIP | DPCONTENTS_BOTCLIP;
	else
		_nade.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_BODY;

	nade_spawn(_nade);

	if(_time)
	{
		_nade.think = nade_boom;
		_nade.nextthink = _time;
	}

	e.nade_refire = time + autocvar_g_nades_nade_refire;
	e.nade_timer = 0;
}

void nades_GiveBonus(entity player, float score)
{
	if (autocvar_g_nades)
	if (autocvar_g_nades_bonus)
	if (IS_REAL_CLIENT(player))
	if (IS_PLAYER(player) && player.bonus_nades < autocvar_g_nades_bonus_max)
	if (STAT(FROZEN, player) == 0)
	if (!IS_DEAD(player))
	{
		if ( player.bonus_nade_score < 1 )
			player.bonus_nade_score += score/autocvar_g_nades_bonus_score_max;

		if ( player.bonus_nade_score >= 1 )
		{
			Send_Notification(NOTIF_ONE, player, MSG_CENTER, CENTER_NADE_BONUS);
			play2(player, SND(KH_ALARM));
			player.bonus_nades++;
			player.bonus_nade_score -= 1;
		}
	}
}

/** Remove all bonus nades from a player */
void nades_RemoveBonus(entity player)
{
	player.bonus_nades = player.bonus_nade_score = 0;
}

MUTATOR_HOOKFUNCTION(nades, PutClientInServer)
{
    SELFPARAM();
	nades_RemoveBonus(self);
}

float nade_customize()
{SELFPARAM();
	//if(IS_SPEC(other)) { return false; }
	if(other == self.exteriormodeltoclient || (IS_SPEC(other) && other.enemy == self.exteriormodeltoclient))
	{
		// somewhat hide the model, but keep the glow
		//self.effects = 0;
		if(self.traileffectnum)
			self.traileffectnum = 0;
		self.alpha = -1;
	}
	else
	{
		//self.effects = EF_ADDITIVE | EF_FULLBRIGHT | EF_LOWPRECISION;
		if(!self.traileffectnum)
			self.traileffectnum = _particleeffectnum(Nade_TrailEffect(Nades_from(self.nade_type).m_projectile[false], self.team).eent_eff_name);
		self.alpha = 1;
	}

	return true;
}

void spawn_held_nade(entity player, entity nowner, float ntime, int ntype, string pntype)
{
	entity n = new(nade), fn = new(fake_nade);

	n.nade_type = bound(1, ntype, Nades_COUNT);
	n.pokenade_type = pntype;

	setmodel(n, MDL_PROJECTILE_NADE);
	//setattachment(n, player, "bip01 l hand");
	n.exteriormodeltoclient = player;
	n.customizeentityforclient = nade_customize;
	n.traileffectnum = _particleeffectnum(Nade_TrailEffect(Nades_from(n.nade_type).m_projectile[false], player.team).eent_eff_name);
	n.colormod = Nades_from(n.nade_type).m_color;
	n.realowner = nowner;
	n.colormap = player.colormap;
	n.glowmod = player.glowmod;
	n.wait = time + max(0, ntime);
	n.nade_time_primed = time;
	n.think = nade_beep;
	n.nextthink = max(n.wait - 3, time);
	n.projectiledeathtype = DEATH_NADE.m_id;

	setmodel(fn, MDL_NADE_VIEW);
	.entity weaponentity = weaponentities[0]; // TODO: unhardcode
	setattachment(fn, player.(weaponentity), "");
	fn.realowner = fn.owner = player;
	fn.colormod = Nades_from(n.nade_type).m_color;
	fn.colormap = player.colormap;
	fn.glowmod = player.glowmod;
	fn.think = SUB_Remove_self;
	fn.nextthink = n.wait;

	player.nade = n;
	player.fake_nade = fn;
}

void nade_prime()
{SELFPARAM();
	if(autocvar_g_nades_bonus_only)
	if(!self.bonus_nades)
		return; // only allow bonus nades

	if(self.nade)
		remove(self.nade);

	if(self.fake_nade)
		remove(self.fake_nade);

	int ntype;
	string pntype = self.pokenade_type;

	if(self.items & ITEM_Strength.m_itemid && autocvar_g_nades_bonus_onstrength)
		ntype = self.nade_type;
	else if (self.bonus_nades >= 1)
	{
		ntype = self.nade_type;
		pntype = self.pokenade_type;
		self.bonus_nades -= 1;
	}
	else
	{
		ntype = ((autocvar_g_nades_client_select) ? self.cvar_cl_nade_type : autocvar_g_nades_nade_type);
		pntype = ((autocvar_g_nades_client_select) ? self.cvar_cl_pokenade_type : autocvar_g_nades_pokenade_monster_type);
	}

	spawn_held_nade(self, self, autocvar_g_nades_nade_lifetime, ntype, pntype);
}

bool CanThrowNade(entity this)
{
	if(this.vehicle)
		return false;

	if(gameover)
		return false;

	if(IS_DEAD(this))
		return false;

	if (!autocvar_g_nades)
		return false; // allow turning them off mid match

	if(forbidWeaponUse(this))
		return false;

	if (!IS_PLAYER(this))
		return false;

	return true;
}

.bool nade_altbutton;

void nades_CheckThrow()
{SELFPARAM();
	if(!CanThrowNade(self))
		return;

	entity held_nade = self.nade;
	if (!held_nade)
	{
		self.nade_altbutton = true;
		if(time > self.nade_refire)
		{
			Send_Notification(NOTIF_ONE, self, MSG_CENTER, CENTER_NADE_THROW);
			nade_prime();
			self.nade_refire = time + autocvar_g_nades_nade_refire;
		}
	}
	else
	{
		self.nade_altbutton = false;
		if (time >= held_nade.nade_time_primed + 1) {
			makevectors(self.v_angle);
			float _force = time - held_nade.nade_time_primed;
			_force /= autocvar_g_nades_nade_lifetime;
			_force = autocvar_g_nades_nade_minforce + (_force * (autocvar_g_nades_nade_maxforce - autocvar_g_nades_nade_minforce));
			vector dir = (v_forward * 0.75 + v_up * 0.2 + v_right * 0.05);
			dir = W_CalculateSpread(dir, autocvar_g_nades_spread, g_weaponspreadfactor, autocvar_g_projectiles_spread_style);
			toss_nade(self, true, dir * _force, 0);
		}
	}
}

void nades_Clear(entity player)
{
	if(player.nade)
		remove(player.nade);
	if(player.fake_nade)
		remove(player.fake_nade);

	player.nade = player.fake_nade = world;
	player.nade_timer = 0;
}

MUTATOR_HOOKFUNCTION(nades, VehicleEnter)
{
	if(vh_player.nade)
		toss_nade(vh_player, true, '0 0 100', max(vh_player.nade.wait, time + 0.05));

	return false;
}

CLASS(NadeOffhand, OffhandWeapon)
    METHOD(NadeOffhand, offhand_think, void(NadeOffhand this, entity player, bool key_pressed))
    {
    	entity held_nade = player.nade;
		if (held_nade)
		{
			player.nade_timer = bound(0, (time - held_nade.nade_time_primed) / autocvar_g_nades_nade_lifetime, 1);
			// LOG_TRACEF("%d %d\n", player.nade_timer, time - held_nade.nade_time_primed);
			makevectors(player.angles);
			held_nade.velocity = player.velocity;
			setorigin(held_nade, player.origin + player.view_ofs + v_forward * 8 + v_right * -8 + v_up * 0);
			held_nade.angles_y = player.angles.y;

			if (time + 0.1 >= held_nade.wait)
				toss_nade(player, false, '0 0 0', time + 0.05);
		}

        if (!CanThrowNade(player)) return;
        if (!(time > player.nade_refire)) return;
		if (key_pressed) {
			if (!held_nade) {
				nade_prime();
				held_nade = player.nade;
			}
		} else if (time >= held_nade.nade_time_primed + 1) {
			if (held_nade) {
				makevectors(player.v_angle);
				float _force = time - held_nade.nade_time_primed;
				_force /= autocvar_g_nades_nade_lifetime;
				_force = autocvar_g_nades_nade_minforce + (_force * (autocvar_g_nades_nade_maxforce - autocvar_g_nades_nade_minforce));
				vector dir = (v_forward * 0.7 + v_up * 0.2 + v_right * 0.1);
				dir = W_CalculateSpread(dir, autocvar_g_nades_spread, g_weaponspreadfactor, autocvar_g_projectiles_spread_style);
				toss_nade(player, false, dir * _force, 0);
			}
		}
    }
ENDCLASS(NadeOffhand)
NadeOffhand OFFHAND_NADE; STATIC_INIT(OFFHAND_NADE) { OFFHAND_NADE = NEW(NadeOffhand); }

MUTATOR_HOOKFUNCTION(nades, ForbidThrowCurrentWeapon, CBC_ORDER_LAST)
{
    SELFPARAM();
	if (self.offhand != OFFHAND_NADE || (self.weapons & WEPSET(HOOK)) || autocvar_g_nades_override_dropweapon) {
		nades_CheckThrow();
		return true;
	}
	return false;
}

MUTATOR_HOOKFUNCTION(nades, PlayerPreThink)
{SELFPARAM();
	if (!IS_PLAYER(self)) { return false; }

	if (self.nade && (self.offhand != OFFHAND_NADE || (self.weapons & WEPSET(HOOK)))) OFFHAND_NADE.offhand_think(OFFHAND_NADE, self, self.nade_altbutton);

	if(IS_PLAYER(self))
	{
		if ( autocvar_g_nades_bonus && autocvar_g_nades )
		{
			entity key;
			float key_count = 0;
			FOR_EACH_KH_KEY(key) if(key.owner == self) { ++key_count; }

			float time_score;
			if(self.flagcarried || self.ballcarried) // this player is important
				time_score = autocvar_g_nades_bonus_score_time_flagcarrier;
			else
				time_score = autocvar_g_nades_bonus_score_time;

			if(key_count)
				time_score = autocvar_g_nades_bonus_score_time_flagcarrier * key_count; // multiply by the number of keys the player is holding

			if(autocvar_g_nades_bonus_client_select)
			{
				self.nade_type = self.cvar_cl_nade_type;
				self.pokenade_type = self.cvar_cl_pokenade_type;
			}
			else
			{
				self.nade_type = autocvar_g_nades_bonus_type;
				self.pokenade_type = autocvar_g_nades_pokenade_monster_type;
			}

			self.nade_type = bound(1, self.nade_type, Nades_COUNT);

			if(self.bonus_nade_score >= 0 && autocvar_g_nades_bonus_score_max)
				nades_GiveBonus(self, time_score / autocvar_g_nades_bonus_score_max);
		}
		else
		{
			self.bonus_nades = self.bonus_nade_score = 0;
		}
	}

	float n = 0;
	entity o = world;
	if(self.freezetag_frozen_timeout > 0 && time >= self.freezetag_frozen_timeout)
		n = -1;
	else
	{
		vector revive_extra_size = '1 1 1' * autocvar_g_freezetag_revive_extra_size;
		n = 0;
		FOREACH_CLIENT(IS_PLAYER(it) && it != self, LAMBDA(
			if(!IS_DEAD(it))
			if(STAT(FROZEN, it) == 0)
			if(SAME_TEAM(it, self))
			if(boxesoverlap(self.absmin - revive_extra_size, self.absmax + revive_extra_size, it.absmin, it.absmax))
			{
				if(!o)
					o = it;
				if(STAT(FROZEN, self) == 1)
					it.reviving = true;
				++n;
			}
		));
	}

	if(n && STAT(FROZEN, self) == 3) // OK, there is at least one teammate reviving us
	{
		self.revive_progress = bound(0, self.revive_progress + frametime * max(1/60, autocvar_g_freezetag_revive_speed), 1);
		self.health = max(1, self.revive_progress * start_health);

		if(self.revive_progress >= 1)
		{
			Unfreeze(self);

			Send_Notification(NOTIF_ONE, self, MSG_CENTER, CENTER_FREEZETAG_REVIVED, o.netname);
			Send_Notification(NOTIF_ONE, o, MSG_CENTER, CENTER_FREEZETAG_REVIVE, self.netname);
		}

		FOREACH_CLIENT(IS_PLAYER(it) && it.reviving, LAMBDA(
			other.revive_progress = self.revive_progress;
			other.reviving = false;
		));
	}

	return false;
}

MUTATOR_HOOKFUNCTION(nades, PlayerSpawn)
{SELFPARAM();
	if(autocvar_g_nades_spawn)
		self.nade_refire = time + autocvar_g_spawnshieldtime;
	else
		self.nade_refire  = time + autocvar_g_nades_nade_refire;

	if(autocvar_g_nades_bonus_client_select)
		self.nade_type = self.cvar_cl_nade_type;

	self.nade_timer = 0;

	if (!self.offhand) self.offhand = OFFHAND_NADE;

	if(self.nade_spawnloc)
	{
		setorigin(self, self.nade_spawnloc.origin);
		self.nade_spawnloc.cnt -= 1;

		if(self.nade_spawnloc.cnt <= 0)
		{
			remove(self.nade_spawnloc);
			self.nade_spawnloc = world;
		}
	}

	return false;
}

MUTATOR_HOOKFUNCTION(nades, PlayerDies, CBC_ORDER_LAST)
{
	if(frag_target.nade)
	if(!STAT(FROZEN, frag_target) || !autocvar_g_freezetag_revive_nade)
		toss_nade(frag_target, true, '0 0 100', max(frag_target.nade.wait, time + 0.05));

	float killcount_bonus = ((frag_attacker.killcount >= 1) ? bound(0, autocvar_g_nades_bonus_score_minor * frag_attacker.killcount, autocvar_g_nades_bonus_score_medium) : autocvar_g_nades_bonus_score_minor);

	if(IS_PLAYER(frag_attacker))
	{
		if (SAME_TEAM(frag_attacker, frag_target) || frag_attacker == frag_target)
			nades_RemoveBonus(frag_attacker);
		else if(frag_target.flagcarried)
			nades_GiveBonus(frag_attacker, autocvar_g_nades_bonus_score_medium);
		else if(autocvar_g_nades_bonus_score_spree && frag_attacker.killcount > 1)
		{
			#define SPREE_ITEM(counta,countb,center,normal,gentle) \
				case counta: { nades_GiveBonus(frag_attacker, autocvar_g_nades_bonus_score_spree); break; }
			switch(frag_attacker.killcount)
			{
				KILL_SPREE_LIST
				default: nades_GiveBonus(frag_attacker, autocvar_g_nades_bonus_score_minor); break;
			}
			#undef SPREE_ITEM
		}
		else
			nades_GiveBonus(frag_attacker, killcount_bonus);
	}

	nades_RemoveBonus(frag_target);

	return false;
}

MUTATOR_HOOKFUNCTION(nades, PlayerDamage_Calculate)
{
	if(STAT(FROZEN, frag_target))
	if(autocvar_g_freezetag_revive_nade)
	if(frag_attacker == frag_target)
	if(frag_deathtype == DEATH_NADE.m_id)
	if(time - frag_inflictor.toss_time <= 0.1)
	{
		Unfreeze(frag_target);
		frag_target.health = autocvar_g_freezetag_revive_nade_health;
		Send_Effect(EFFECT_ICEORGLASS, frag_target.origin, '0 0 0', 3);
		frag_damage = 0;
		frag_force = '0 0 0';
		Send_Notification(NOTIF_ALL, world, MSG_INFO, INFO_FREEZETAG_REVIVED_NADE, frag_target.netname);
		Send_Notification(NOTIF_ONE, frag_target, MSG_CENTER, CENTER_FREEZETAG_REVIVE_SELF);
	}

	return false;
}

MUTATOR_HOOKFUNCTION(nades, MonsterDies)
{
	if(IS_PLAYER(frag_attacker))
	if(DIFF_TEAM(frag_attacker, frag_target))
	if(!(frag_target.spawnflags & MONSTERFLAG_SPAWNED))
		nades_GiveBonus(frag_attacker, autocvar_g_nades_bonus_score_minor);

	return false;
}

MUTATOR_HOOKFUNCTION(nades, DropSpecialItems)
{
	if(frag_target.nade)
		toss_nade(frag_target, true, '0 0 0', time + 0.05);

	return false;
}

bool nades_RemovePlayer()
{SELFPARAM();
	nades_Clear(self);
	nades_RemoveBonus(self);
	return false;
}

MUTATOR_HOOKFUNCTION(nades, MakePlayerObserver) { nades_RemovePlayer(); }
MUTATOR_HOOKFUNCTION(nades, ClientDisconnect) { nades_RemovePlayer(); }
MUTATOR_HOOKFUNCTION(nades, reset_map_global) { nades_RemovePlayer(); }

MUTATOR_HOOKFUNCTION(nades, SpectateCopy)
{SELFPARAM();
	self.nade_timer = other.nade_timer;
	self.nade_type = other.nade_type;
	self.pokenade_type = other.pokenade_type;
	self.bonus_nades = other.bonus_nades;
	self.bonus_nade_score = other.bonus_nade_score;
	self.stat_healing_orb = other.stat_healing_orb;
	self.stat_healing_orb_alpha = other.stat_healing_orb_alpha;
	return false;
}

REPLICATE(cvar_cl_nade_type, int, "cl_nade_type");
REPLICATE(cvar_cl_pokenade_type, string, "cl_pokenade_type");

MUTATOR_HOOKFUNCTION(nades, BuildMutatorsString)
{
	ret_string = strcat(ret_string, ":Nades");
	return false;
}

MUTATOR_HOOKFUNCTION(nades, BuildMutatorsPrettyString)
{
	ret_string = strcat(ret_string, ", Nades");
	return false;
}

MUTATOR_HOOKFUNCTION(nades, BuildGameplayTipsString)
{
	ret_string = strcat(ret_string, "\n\n^3nades^8 are enabled, press 'g' to use them\n");
	return false;
}

#endif
#endif
