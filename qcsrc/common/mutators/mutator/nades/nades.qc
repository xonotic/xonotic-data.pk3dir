#include "nades.qh"

#ifdef IMPLEMENTATION

#ifdef SVQC
bool autocvar_g_nades_nade_small;
float autocvar_g_nades_spread = 0.04;
#endif

REGISTER_STAT(NADES_SMALL, int, autocvar_g_nades_nade_small)

#ifndef MENUQC
entity Nade_TrailEffect(int proj, int nade_team)
{
    switch (proj)
    {
        case PROJECTILE_NADE:       return EFFECT_NADE_TRAIL(nade_team);
        case PROJECTILE_NADE_BURN:  return EFFECT_NADE_TRAIL_BURN(nade_team);
    }

    FOREACH(Nades, true, LAMBDA(
        for (int j = 0; j < 2; j++)
        {
            if (it.m_projectile[j] == proj)
            {
                string trail = it.m_trail[j].eent_eff_name;
                if (trail) return it.m_trail[j];
                break;
            }
        }
    ));

    return EFFECT_Null;
}
#endif

#ifdef CSQC
REGISTER_MUTATOR(cl_nades, true);
MUTATOR_HOOKFUNCTION(cl_nades, HUD_Draw_overlay)
{
	if (STAT(HEALING_ORB) > time)
	{
		M_ARGV(0, vector) = NADE_TYPE_HEAL.m_color;
		M_ARGV(1, float) = STAT(HEALING_ORB_ALPHA);
		return true;
	}
	if (STAT(ENTRAP_ORB) > time)
	{
		M_ARGV(0, vector) = NADE_TYPE_ENTRAP.m_color;
		M_ARGV(1, float) = STAT(ENTRAP_ORB_ALPHA);
		return true;
	}
	return false;
}
MUTATOR_HOOKFUNCTION(cl_nades, Ent_Projectile)
{
	entity proj = M_ARGV(0, entity);

	if (proj.cnt == PROJECTILE_NAPALM_FOUNTAIN)
	{
		proj.modelindex = 0;
		proj.traileffect = EFFECT_FIREBALL.m_id;
		return true;
	}
	if (Nade_FromProjectile(proj.cnt) != NADE_TYPE_Null)
	{
		setmodel(proj, MDL_PROJECTILE_NADE);
		entity trail = Nade_TrailEffect(proj.cnt, proj.team);
		if (trail.eent_eff_name) proj.traileffect = trail.m_id;
		return true;
	}
}
MUTATOR_HOOKFUNCTION(cl_nades, EditProjectile)
{
	entity proj = M_ARGV(0, entity);

	if (proj.cnt == PROJECTILE_NAPALM_FOUNTAIN)
	{
		loopsound(proj, CH_SHOTS_SINGLE, SND(FIREBALL_FLY2), VOL_BASE, ATTEN_NORM);
		proj.mins = '-16 -16 -16';
		proj.maxs = '16 16 16';
	}

	entity nade_type = Nade_FromProjectile(proj.cnt);
	if (nade_type == NADE_TYPE_Null) return;
	if(STAT(NADES_SMALL, NULL))
	{
		proj.mins = '-8 -8 -8';
		proj.maxs = '8 8 8';
	}
	else
	{
		proj.mins = '-16 -16 -16';
		proj.maxs = '16 16 16';
	}
	proj.colormod = nade_type.m_color;
	proj.move_movetype = MOVETYPE_BOUNCE;
	settouch(proj, func_null);
	proj.scale = 1.5;
	proj.avelocity = randomvec() * 720;

	if (nade_type == NADE_TYPE_TRANSLOCATE || nade_type == NADE_TYPE_SPAWN)
		proj.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_PLAYERCLIP | DPCONTENTS_BOTCLIP;
	else
		proj.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_BODY;
}
bool Projectile_isnade(int p)
{
	return Nade_FromProjectile(p) != NADE_TYPE_Null;
}
void DrawAmmoNades(vector myPos, vector mySize, bool draw_expanding, float expand_time)
{
	float bonusNades    = STAT(NADE_BONUS);
	float bonusProgress = STAT(NADE_BONUS_SCORE);
	float bonusType     = STAT(NADE_BONUS_TYPE);
	Nade def = Nades_from(bonusType);
	vector nadeColor    = def.m_color;
	string nadeIcon     = def.m_icon;

	vector iconPos, textPos;

	if(autocvar_hud_panel_ammo_iconalign)
	{
		iconPos = myPos + eX * 2 * mySize.y;
		textPos = myPos;
	}
	else
	{
		iconPos = myPos;
		textPos = myPos + eX * mySize.y;
	}

	if(bonusNades > 0 || bonusProgress > 0)
	{
		DrawNadeProgressBar(myPos, mySize, bonusProgress, nadeColor);

		if(autocvar_hud_panel_ammo_text)
			drawstring_aspect(textPos, ftos(bonusNades), eX * (2/3) * mySize.x + eY * mySize.y, '1 1 1', panel_fg_alpha, DRAWFLAG_NORMAL);

		if(draw_expanding)
			drawpic_aspect_skin_expanding(iconPos, nadeIcon, '1 1 0' * mySize.y, '1 1 1', panel_fg_alpha, DRAWFLAG_NORMAL, expand_time);

		drawpic_aspect_skin(iconPos, nadeIcon, '1 1 0' * mySize.y, '1 1 1', panel_fg_alpha, DRAWFLAG_NORMAL);
	}
}
#endif

#ifdef SVQC

#include <common/gamemodes/all.qh>
#include <common/monsters/spawn.qh>
#include <common/monsters/sv_monsters.qh>
#include <server/g_subs.qh>

REGISTER_MUTATOR(nades, cvar("g_nades"));

.float nade_time_primed;

.entity nade_spawnloc;

void nade_timer_think(entity this)
{
	this.skin = 8 - (this.owner.wait - time) / (autocvar_g_nades_nade_lifetime / 10);
	this.nextthink = time;
	if(!this.owner || wasfreed(this.owner))
		remove(this);
}

void nade_burn_spawn(entity _nade)
{
	CSQCProjectile(_nade, true, Nades_from(_nade.nade_type).m_projectile[true], true);
}

void nade_spawn(entity _nade)
{
	entity timer = new(nade_timer);
	setmodel(timer, MDL_NADE_TIMER);
	setattachment(timer, _nade, "");
	timer.colormap = _nade.colormap;
	timer.glowmod = _nade.glowmod;
	setthink(timer, nade_timer_think);
	timer.nextthink = time;
	timer.wait = _nade.wait;
	timer.owner = _nade;
	timer.skin = 10;

	_nade.effects |= EF_LOWPRECISION;

	CSQCProjectile(_nade, true, Nades_from(_nade.nade_type).m_projectile[false], true);
}

void napalm_damage(entity this, float dist, float damage, float edgedamage, float burntime)
{
	entity e;
	float d;
	vector p;

	if ( damage < 0 )
		return;

	RandomSelection_Init();
	for(e = WarpZone_FindRadius(this.origin, dist, true); e; e = e.chain)
		if(e.takedamage == DAMAGE_AIM)
		if(this.realowner != e || autocvar_g_nades_napalm_selfdamage)
		if(!IS_PLAYER(e) || !this.realowner || DIFF_TEAM(e, this))
		if(!STAT(FROZEN, e))
		{
			p = e.origin;
			p.x += e.mins.x + random() * (e.maxs.x - e.mins.x);
			p.y += e.mins.y + random() * (e.maxs.y - e.mins.y);
			p.z += e.mins.z + random() * (e.maxs.z - e.mins.z);
			d = vlen(WarpZone_UnTransformOrigin(e, this.origin) - p);
			if(d < dist)
			{
				e.fireball_impactvec = p;
				RandomSelection_Add(e, 0, string_null, 1 / (1 + d), !Fire_IsBurning(e));
			}
		}
	if(RandomSelection_chosen_ent)
	{
		d = vlen(WarpZone_UnTransformOrigin(RandomSelection_chosen_ent, this.origin) - RandomSelection_chosen_ent.fireball_impactvec);
		d = damage + (edgedamage - damage) * (d / dist);
		Fire_AddDamage(RandomSelection_chosen_ent, this.realowner, d * burntime, burntime, this.projectiledeathtype | HITTYPE_BOUNCE);
		//trailparticles(this, particleeffectnum(EFFECT_FIREBALL_LASER), this.origin, RandomSelection_chosen_ent.fireball_impactvec);
		Send_Effect(EFFECT_FIREBALL_LASER, this.origin, RandomSelection_chosen_ent.fireball_impactvec - this.origin, 1);
	}
}


void napalm_ball_think(entity this)
{
	if(round_handler_IsActive())
	if(!round_handler_IsRoundStarted())
	{
		remove(this);
		return;
	}

	if(time > this.pushltime)
	{
		remove(this);
		return;
	}

	vector midpoint = ((this.absmin + this.absmax) * 0.5);
	if(pointcontents(midpoint) == CONTENT_WATER)
	{
		this.velocity = this.velocity * 0.5;

		if(pointcontents(midpoint + '0 0 16') == CONTENT_WATER)
			{ this.velocity_z = 200; }
	}

	this.angles = vectoangles(this.velocity);

	napalm_damage(this, autocvar_g_nades_napalm_ball_radius,autocvar_g_nades_napalm_ball_damage,
				  autocvar_g_nades_napalm_ball_damage,autocvar_g_nades_napalm_burntime);

	this.nextthink = time + 0.1;
}


void nade_napalm_ball(entity this)
{
	entity proj;
	vector kick;

	spamsound(this, CH_SHOTS, SND(FIREBALL_FIRE), VOL_BASE, ATTEN_NORM);

	proj = new(grenade);
	proj.owner = this.owner;
	proj.realowner = this.realowner;
	proj.team = this.owner.team;
	proj.bot_dodge = true;
	proj.bot_dodgerating = autocvar_g_nades_napalm_ball_damage;
	proj.movetype = MOVETYPE_BOUNCE;
	proj.projectiledeathtype = DEATH_NADE_NAPALM.m_id;
	PROJECTILE_MAKETRIGGER(proj);
	setmodel(proj, MDL_Null);
	proj.scale = 1;//0.5;
	setsize(proj, '-4 -4 -4', '4 4 4');
	setorigin(proj, this.origin);
	setthink(proj, napalm_ball_think);
	proj.nextthink = time;
	proj.damageforcescale = autocvar_g_nades_napalm_ball_damageforcescale;
	proj.effects = EF_LOWPRECISION | EF_FLAME;

	kick.x =(random() - 0.5) * 2 * autocvar_g_nades_napalm_ball_spread;
	kick.y = (random() - 0.5) * 2 * autocvar_g_nades_napalm_ball_spread;
	kick.z = (random()/2+0.5) * autocvar_g_nades_napalm_ball_spread;
	proj.velocity = kick;

	proj.pushltime = time + autocvar_g_nades_napalm_ball_lifetime;

	proj.angles = vectoangles(proj.velocity);
	proj.flags = FL_PROJECTILE;
	proj.missile_flags = MIF_SPLASH | MIF_PROXY | MIF_ARC;

	//CSQCProjectile(proj, true, PROJECTILE_NAPALM_FIRE, true);
}


void napalm_fountain_think(entity this)
{

	if(round_handler_IsActive())
	if(!round_handler_IsRoundStarted())
	{
		remove(this);
		return;
	}

	if(time >= this.ltime)
	{
		remove(this);
		return;
	}

	vector midpoint = ((this.absmin + this.absmax) * 0.5);
	if(pointcontents(midpoint) == CONTENT_WATER)
	{
		this.velocity = this.velocity * 0.5;

		if(pointcontents(midpoint + '0 0 16') == CONTENT_WATER)
			{ this.velocity_z = 200; }

		UpdateCSQCProjectile(this);
	}

	napalm_damage(this, autocvar_g_nades_napalm_fountain_radius, autocvar_g_nades_napalm_fountain_damage,
		autocvar_g_nades_napalm_fountain_edgedamage, autocvar_g_nades_napalm_burntime);

	this.nextthink = time + 0.1;
	if(time >= this.nade_special_time)
	{
		this.nade_special_time = time + autocvar_g_nades_napalm_fountain_delay;
		nade_napalm_ball(this);
	}
}

void nade_napalm_boom(entity this)
{
	entity fountain;
	int c;
	for (c = 0; c < autocvar_g_nades_napalm_ball_count; c++)
		nade_napalm_ball(this);


	fountain = spawn();
	fountain.owner = this.owner;
	fountain.realowner = this.realowner;
	fountain.origin = this.origin;
	setorigin(fountain, fountain.origin);
	setthink(fountain, napalm_fountain_think);
	fountain.nextthink = time;
	fountain.ltime = time + autocvar_g_nades_napalm_fountain_lifetime;
	fountain.pushltime = fountain.ltime;
	fountain.team = this.team;
	fountain.movetype = MOVETYPE_TOSS;
	fountain.projectiledeathtype = DEATH_NADE_NAPALM.m_id;
	fountain.bot_dodge = true;
	fountain.bot_dodgerating = autocvar_g_nades_napalm_fountain_damage;
	fountain.nade_special_time = time;
	setsize(fountain, '-16 -16 -16', '16 16 16');
	CSQCProjectile(fountain, true, PROJECTILE_NAPALM_FOUNTAIN, true);
}

void nade_ice_freeze(entity freezefield, entity frost_target, float freeze_time)
{
	frost_target.frozen_by = freezefield.realowner;
	Send_Effect(EFFECT_ELECTRO_IMPACT, frost_target.origin, '0 0 0', 1);
	Freeze(frost_target, 1/freeze_time, 3, false);

	Drop_Special_Items(frost_target);
}

void nade_ice_think(entity this)
{
	if(round_handler_IsActive())
	if(!round_handler_IsRoundStarted())
	{
		remove(this);
		return;
	}

	if(time >= this.ltime)
	{
		if ( autocvar_g_nades_ice_explode )
		{
			entity expef = EFFECT_NADE_EXPLODE(this.realowner.team);
			Send_Effect(expef, this.origin + '0 0 1', '0 0 0', 1);
			sound(this, CH_SHOTS, SND_ROCKET_IMPACT, VOL_BASE, ATTEN_NORM);

			RadiusDamage(this, this.realowner, autocvar_g_nades_nade_damage, autocvar_g_nades_nade_edgedamage,
				autocvar_g_nades_nade_radius, this, NULL, autocvar_g_nades_nade_force, this.projectiledeathtype, this.enemy);
			Damage_DamageInfo(this.origin, autocvar_g_nades_nade_damage, autocvar_g_nades_nade_edgedamage,
				autocvar_g_nades_nade_radius, '1 1 1' * autocvar_g_nades_nade_force, this.projectiledeathtype, 0, this);
		}
		remove(this);
		return;
	}


	this.nextthink = time+0.1;

	// gaussian
	float randomr;
	randomr = random();
	randomr = exp(-5*randomr*randomr)*autocvar_g_nades_nade_radius;
	float randomw;
	randomw = random()*M_PI*2;
	vector randomp;
	randomp.x = randomr*cos(randomw);
	randomp.y = randomr*sin(randomw);
	randomp.z = 1;
	Send_Effect(EFFECT_ELECTRO_MUZZLEFLASH, this.origin + randomp, '0 0 0', 1);

	if(time >= this.nade_special_time)
	{
		this.nade_special_time = time+0.7;

		Send_Effect(EFFECT_ELECTRO_IMPACT, this.origin, '0 0 0', 1);
		Send_Effect(EFFECT_ICEFIELD, this.origin, '0 0 0', 1);
	}


	float current_freeze_time = this.ltime - time - 0.1;

	FOREACH_ENTITY_RADIUS(this.origin, autocvar_g_nades_nade_radius, it != this && it.takedamage && !IS_DEAD(it) && it.health > 0 && current_freeze_time > 0,
	{
		if(!autocvar_g_nades_ice_teamcheck || (DIFF_TEAM(it, this.realowner) || it == this.realowner))
		if(!it.revival_time || ((time - it.revival_time) >= 1.5))
		if(!STAT(FROZEN, it))
			nade_ice_freeze(this, it, current_freeze_time);
	});
}

void nade_ice_boom(entity this)
{
	entity fountain;
	fountain = spawn();
	fountain.owner = this.owner;
	fountain.realowner = this.realowner;
	fountain.origin = this.origin;
	setorigin(fountain, fountain.origin);
	setthink(fountain, nade_ice_think);
	fountain.nextthink = time;
	fountain.ltime = time + autocvar_g_nades_ice_freeze_time;
	fountain.pushltime = fountain.wait = fountain.ltime;
	fountain.team = this.team;
	fountain.movetype = MOVETYPE_TOSS;
	fountain.projectiledeathtype = DEATH_NADE_ICE.m_id;
	fountain.bot_dodge = false;
	setsize(fountain, '-16 -16 -16', '16 16 16');
	fountain.nade_special_time = time+0.3;
	fountain.angles = this.angles;

	if ( autocvar_g_nades_ice_explode )
	{
		setmodel(fountain, MDL_PROJECTILE_GRENADE);
		entity timer = new(nade_timer);
		setmodel(timer, MDL_NADE_TIMER);
		setattachment(timer, fountain, "");
		timer.colormap = this.colormap;
		timer.glowmod = this.glowmod;
		setthink(timer, nade_timer_think);
		timer.nextthink = time;
		timer.wait = fountain.ltime;
		timer.owner = fountain;
		timer.skin = 10;
	}
	else
		setmodel(fountain, MDL_Null);
}

void nade_translocate_boom(entity this)
{
	if(this.realowner.vehicle)
		return;

	vector locout = this.origin + '0 0 1' * (1 - this.realowner.mins.z - 24);
	tracebox(locout, this.realowner.mins, this.realowner.maxs, locout, MOVE_NOMONSTERS, this.realowner);
	locout = trace_endpos;

	makevectors(this.realowner.angles);

	MUTATOR_CALLHOOK(PortalTeleport, this.realowner);

	TeleportPlayer(this, this.realowner, locout, this.realowner.angles, v_forward * vlen(this.realowner.velocity), '0 0 0', '0 0 0', TELEPORT_FLAGS_TELEPORTER);
}

void nade_spawn_boom(entity this)
{
	entity spawnloc = spawn();
	setorigin(spawnloc, this.origin);
	setsize(spawnloc, this.realowner.mins, this.realowner.maxs);
	spawnloc.movetype = MOVETYPE_NONE;
	spawnloc.solid = SOLID_NOT;
	spawnloc.drawonlytoclient = this.realowner;
	spawnloc.effects = EF_STARDUST;
	spawnloc.cnt = autocvar_g_nades_spawn_count;

	if(this.realowner.nade_spawnloc)
	{
		remove(this.realowner.nade_spawnloc);
		this.realowner.nade_spawnloc = NULL;
	}

	this.realowner.nade_spawnloc = spawnloc;
}

void nades_orb_think(entity this)
{
	if(time >= this.ltime)
	{
		remove(this);
		return;
	}

	this.nextthink = time;

	if(time >= this.nade_special_time)
	{
		this.nade_special_time = time+0.25;
		this.nade_show_particles = 1;
	}
	else
		this.nade_show_particles = 0;
}

entity nades_spawn_orb(entity own, entity realown, vector org, float orb_ltime, float orb_rad)
{
	// NOTE: this function merely places an orb
	// you must add a custom touch function to the returned entity if desired
	// also set .colormod if you wish to have it colorized
	entity orb = spawn(); // Net_LinkEntity sets the classname (TODO)
	orb.owner = own;
	orb.realowner = realown;
	setorigin(orb, org);

	orb.orb_lifetime = orb_ltime; // required for timers
	orb.ltime = time + orb.orb_lifetime;
	orb.bot_dodge = false;
	orb.team = realown.team;
	orb.solid = SOLID_TRIGGER;

	setmodel(orb, MDL_NADE_ORB);
	orb.skin = 1;
	orb.orb_radius = orb_rad; // required for fading
	vector size = '1 1 1' * orb.orb_radius / 2;
	setsize(orb, -size, size);

	Net_LinkEntity(orb, true, 0, orb_send);
	orb.SendFlags |= 1;

	setthink(orb, nades_orb_think);
	orb.nextthink = time;

	return orb;
}

void nade_entrap_touch(entity this)
{
	if(DIFF_TEAM(other, this.realowner)) // TODO: what if realowner changes team or disconnects?
	{
		if (!isPushable(other))
			return;

		float pushdeltatime = time - other.lastpushtime;
		if (pushdeltatime > 0.15) pushdeltatime = 0;
		other.lastpushtime = time;
		if(!pushdeltatime) return;

		// div0: ticrate independent, 1 = identity (not 20)
#ifdef SVQC
		other.velocity = other.velocity * pow(autocvar_g_nades_entrap_strength, pushdeltatime);

		UpdateCSQCProjectile(other);
#elif defined(CSQC)
		other.move_velocity = other.move_velocity * pow(autocvar_g_nades_entrap_strength, pushdeltatime);
#endif
	}

	if ( IS_REAL_CLIENT(other) || IS_VEHICLE(other) || IS_MONSTER(other) )
	{
		entity show_tint = (IS_VEHICLE(other)) ? other.owner : other;
		STAT(ENTRAP_ORB, show_tint) = time + 0.1;

		float tint_alpha = 0.75;
		if(SAME_TEAM(other, this.realowner))
			tint_alpha = 0.45;
		STAT(ENTRAP_ORB_ALPHA, show_tint) = tint_alpha * (this.ltime - time) / this.orb_lifetime;
	}
}

void nade_entrap_boom(entity this)
{
	entity orb = nades_spawn_orb(this.owner, this.realowner, this.origin, autocvar_g_nades_entrap_time, autocvar_g_nades_entrap_radius);

	settouch(orb, nade_entrap_touch);
	orb.colormod = NADE_TYPE_ENTRAP.m_color;
}

void nade_heal_touch(entity this)
{
	float maxhealth;
	float health_factor;
	if(IS_PLAYER(other) || IS_MONSTER(other))
	if(!IS_DEAD(other))
	if(!STAT(FROZEN, other))
	{
		health_factor = autocvar_g_nades_heal_rate*frametime/2;
		if ( other != this.realowner )
		{
			if ( SAME_TEAM(other,this) )
				health_factor *= autocvar_g_nades_heal_friend;
			else
				health_factor *= autocvar_g_nades_heal_foe;
		}
		if ( health_factor > 0 )
		{
			maxhealth = (IS_MONSTER(other)) ? other.max_health : g_pickup_healthmega_max;
			if ( other.health < maxhealth )
			{
				if ( this.nade_show_particles )
					Send_Effect(EFFECT_HEALING, other.origin, '0 0 0', 1);
				other.health = min(other.health+health_factor, maxhealth);
			}
			other.pauserothealth_finished = max(other.pauserothealth_finished, time + autocvar_g_balance_pause_health_rot);
		}
		else if ( health_factor < 0 )
		{
			Damage(other,this,this.realowner,-health_factor,DEATH_NADE_HEAL.m_id,other.origin,'0 0 0');
		}

	}

	if ( IS_REAL_CLIENT(other) || IS_VEHICLE(other) )
	{
		entity show_red = (IS_VEHICLE(other)) ? other.owner : other;
		show_red.stat_healing_orb = time+0.1;
		show_red.stat_healing_orb_alpha = 0.75 * (this.ltime - time) / this.orb_lifetime;
	}
}

void nade_heal_boom(entity this)
{
	entity orb = nades_spawn_orb(this.owner, this.realowner, this.origin, autocvar_g_nades_heal_time, autocvar_g_nades_nade_radius);

	settouch(orb, nade_heal_touch);
	orb.colormod = '1 0 0';
}

void nade_monster_boom(entity this)
{
	entity e = spawnmonster(this.pokenade_type, 0, this.realowner, this.realowner, this.origin, false, false, 1);

	if(autocvar_g_nades_pokenade_monster_lifetime > 0)
		e.monster_lifetime = time + autocvar_g_nades_pokenade_monster_lifetime;
	e.monster_skill = MONSTER_SKILL_INSANE;
}

void nade_boom(entity this)
{
	entity expef = NULL;
	bool nade_blast = true;

	switch ( Nades_from(this.nade_type) )
	{
		case NADE_TYPE_NAPALM:
			nade_blast = autocvar_g_nades_napalm_blast;
			expef = EFFECT_EXPLOSION_MEDIUM;
			break;
		case NADE_TYPE_ICE:
			nade_blast = false;
			expef = EFFECT_ELECTRO_COMBO; // hookbomb_explode electro_combo bigplasma_impact
			break;
		case NADE_TYPE_TRANSLOCATE:
			nade_blast = false;
			break;
		case NADE_TYPE_MONSTER:
		case NADE_TYPE_SPAWN:
			nade_blast = false;
			switch(this.realowner.team)
			{
				case NUM_TEAM_1: expef = EFFECT_SPAWN_RED; break;
				case NUM_TEAM_2: expef = EFFECT_SPAWN_BLUE; break;
				case NUM_TEAM_3: expef = EFFECT_SPAWN_YELLOW; break;
				case NUM_TEAM_4: expef = EFFECT_SPAWN_PINK; break;
				default: expef = EFFECT_SPAWN_NEUTRAL; break;
			}
			break;
		case NADE_TYPE_HEAL:
			nade_blast = false;
			expef = EFFECT_SPAWN_RED;
			break;

		case NADE_TYPE_ENTRAP:
			nade_blast = false;
			expef = EFFECT_SPAWN_YELLOW;
			break;

		default:
		case NADE_TYPE_NORMAL:
			expef = EFFECT_NADE_EXPLODE(this.realowner.team);
			break;
	}

	if(expef)
		Send_Effect(expef, findbetterlocation(this.origin, 8), '0 0 0', 1);

	sound(this, CH_SHOTS_SINGLE, SND_Null, VOL_BASE, ATTEN_NORM);
	sound(this, CH_SHOTS, SND_ROCKET_IMPACT, VOL_BASE, ATTEN_NORM);

	this.event_damage = func_null; // prevent somehow calling damage in the next call

	if(nade_blast)
	{
		RadiusDamage(this, this.realowner, autocvar_g_nades_nade_damage, autocvar_g_nades_nade_edgedamage,
				 autocvar_g_nades_nade_radius, this, NULL, autocvar_g_nades_nade_force, this.projectiledeathtype, this.enemy);
		Damage_DamageInfo(this.origin, autocvar_g_nades_nade_damage, autocvar_g_nades_nade_edgedamage, autocvar_g_nades_nade_radius, '1 1 1' * autocvar_g_nades_nade_force, this.projectiledeathtype, 0, this);
	}

	if(this.takedamage)
	switch ( Nades_from(this.nade_type) )
	{
		case NADE_TYPE_NAPALM: nade_napalm_boom(this); break;
		case NADE_TYPE_ICE: nade_ice_boom(this); break;
		case NADE_TYPE_TRANSLOCATE: nade_translocate_boom(this); break;
		case NADE_TYPE_SPAWN: nade_spawn_boom(this); break;
		case NADE_TYPE_HEAL: nade_heal_boom(this); break;
		case NADE_TYPE_MONSTER: nade_monster_boom(this); break;
		case NADE_TYPE_ENTRAP: nade_entrap_boom(this); break;
	}

	FOREACH_ENTITY_ENT(aiment, this,
	{
		if(it.classname == "grapplinghook")
			RemoveGrapplingHook(it.realowner);
	});

	remove(this);
}

void spawn_held_nade(entity player, entity nowner, float ntime, int ntype, string pntype);
void nade_pickup(entity this, entity thenade)
{
	spawn_held_nade(this, thenade.realowner, autocvar_g_nades_pickup_time, thenade.nade_type, thenade.pokenade_type);

	// set refire so player can't even
	this.nade_refire = time + autocvar_g_nades_nade_refire;
	this.nade_timer = 0;

	if(this.nade)
		this.nade.nade_time_primed = thenade.nade_time_primed;
}

bool CanThrowNade(entity this);
void nade_touch(entity this)
{
	if(other)
		UpdateCSQCProjectile(this);

	if(other == this.realowner)
		return; // no this impacts

	if(autocvar_g_nades_pickup)
	if(time >= this.spawnshieldtime)
	if(!other.nade && this.health == this.max_health) // no boosted shot pickups, thank you very much
	if(!other.frozen)
	if(CanThrowNade(other)) // prevent some obvious things, like dead players
	if(IS_REAL_CLIENT(other)) // above checks for IS_PLAYER, don't need to do it here
	{
		nade_pickup(other, this);
		sound(this, CH_SHOTS_SINGLE, SND_Null, VOL_BASE, 0.5 *(ATTEN_LARGE + ATTEN_MAX));
		remove(this);
		return;
	}
	/*float is_weapclip = 0;
	if(trace_dphitq3surfaceflags & Q3SURFACEFLAG_NODRAW)
	if (!(trace_dphitq3surfaceflags & Q3SURFACEFLAG_NONSOLID))
	if (!(trace_dphitcontents & DPCONTENTS_OPAQUE))
		is_weapclip = 1;*/
	if(ITEM_TOUCH_NEEDKILL()) // || is_weapclip)
	{
		FOREACH_ENTITY_ENT(aiment, this,
		{
			if(it.classname == "grapplinghook")
				RemoveGrapplingHook(it.realowner);
		});
		remove(this);
		return;
	}

	PROJECTILE_TOUCH(this);

	//setsize(this, '-2 -2 -2', '2 2 2');
	//UpdateCSQCProjectile(this);
	if(this.health == this.max_health)
	{
		spamsound(this, CH_SHOTS, SND(GRENADE_BOUNCE_RANDOM()), VOL_BASE, ATTEN_NORM);
		return;
	}

	this.enemy = other;
	nade_boom(this);
}

void nade_beep(entity this)
{
	sound(this, CH_SHOTS_SINGLE, SND_NADE_BEEP, VOL_BASE, 0.5 *(ATTEN_LARGE + ATTEN_MAX));
	setthink(this, nade_boom);
	this.nextthink = max(this.wait, time);
}

void nade_damage(entity this, entity inflictor, entity attacker, float damage, int deathtype, vector hitloc, vector force)
{
	if(ITEM_DAMAGE_NEEDKILL(deathtype))
	{
		this.takedamage = DAMAGE_NO;
		nade_boom(this);
		return;
	}

	if(this.nade_type == NADE_TYPE_TRANSLOCATE.m_id || this.nade_type == NADE_TYPE_SPAWN.m_id)
		return;

	if (MUTATOR_CALLHOOK(Nade_Damage, this, DEATH_WEAPONOF(deathtype), force, damage)) {}
	else if(DEATH_ISWEAPON(deathtype, WEP_BLASTER))
	{
		force *= 1.5;
		damage = 0;
	}
	else if(DEATH_ISWEAPON(deathtype, WEP_VAPORIZER) && (deathtype & HITTYPE_SECONDARY))
	{
		force *= 0.5; // too much
		damage = 0;
	}
	else if(DEATH_ISWEAPON(deathtype, WEP_VORTEX) || DEATH_ISWEAPON(deathtype, WEP_VAPORIZER))
	{
		force *= 6;
		damage = this.max_health * 0.55;
	}
	else if(DEATH_ISWEAPON(deathtype, WEP_MACHINEGUN))
		damage = this.max_health * 0.1;
	else if(DEATH_ISWEAPON(deathtype, WEP_SHOCKWAVE) || DEATH_ISWEAPON(deathtype, WEP_SHOTGUN)) // WEAPONTODO
	{
		if(deathtype & HITTYPE_SECONDARY)
		{
			damage = this.max_health * 0.1;
			force *= 10;
		}
		else
			damage = this.max_health * 1.15;
	}

	this.velocity += force;
	UpdateCSQCProjectile(this);

	if(damage <= 0 || ((IS_ONGROUND(this)) && IS_PLAYER(attacker)))
		return;

	if(this.health == this.max_health)
	{
		sound(this, CH_SHOTS_SINGLE, SND_Null, VOL_BASE, 0.5 *(ATTEN_LARGE + ATTEN_MAX));
		this.nextthink = max(time + autocvar_g_nades_nade_lifetime, time);
		setthink(this, nade_beep);
	}

	this.health -= damage;

	if ( this.nade_type != NADE_TYPE_HEAL.m_id || IS_PLAYER(attacker) )
		this.realowner = attacker;

	if(this.health <= 0)
		W_PrepareExplosionByDamage(this, attacker, nade_boom);
	else
		nade_burn_spawn(this);
}

void toss_nade(entity e, bool set_owner, vector _velocity, float _time)
{
	if(e.nade == NULL)
		return;

	entity _nade = e.nade;
	e.nade = NULL;

	remove(e.fake_nade);
	e.fake_nade = NULL;

	makevectors(e.v_angle);

	W_SetupShot(e, false, false, SND_Null, CH_WEAPON_A, 0);

	Kill_Notification(NOTIF_ONE_ONLY, e, MSG_CENTER, CPID_NADES);

	vector offset = (v_forward * autocvar_g_nades_throw_offset.x)
				  + (v_right * autocvar_g_nades_throw_offset.y)
				  + (v_up * autocvar_g_nades_throw_offset.z);
	if(autocvar_g_nades_throw_offset == '0 0 0')
		offset = '0 0 0';

	setorigin(_nade, w_shotorg + offset + (v_right * 25) * -1);
	//setmodel(_nade, MDL_PROJECTILE_NADE);
	//setattachment(_nade, NULL, "");
	PROJECTILE_MAKETRIGGER(_nade);
	if(STAT(NADES_SMALL, e))
		setsize(_nade, '-8 -8 -8', '8 8 8');
	else
		setsize(_nade, '-16 -16 -16', '16 16 16');
	_nade.movetype = MOVETYPE_BOUNCE;

	tracebox(_nade.origin, _nade.mins, _nade.maxs, _nade.origin, false, _nade);
	if (trace_startsolid)
		setorigin(_nade, e.origin);

	if(e.v_angle.x >= 70 && e.v_angle.x <= 110 && PHYS_INPUT_BUTTON_CROUCH(e))
		_nade.velocity = '0 0 100';
	else if(autocvar_g_nades_nade_newton_style == 1)
		_nade.velocity = e.velocity + _velocity;
	else if(autocvar_g_nades_nade_newton_style == 2)
		_nade.velocity = _velocity;
	else
		_nade.velocity = W_CalculateProjectileVelocity(e, e.velocity, _velocity, true);

	if(set_owner)
		_nade.realowner = e;

	settouch(_nade, nade_touch);
	_nade.spawnshieldtime = time + 0.1; // prevent instantly picking up again
	_nade.health = autocvar_g_nades_nade_health;
	_nade.max_health = _nade.health;
	_nade.takedamage = DAMAGE_AIM;
	_nade.event_damage = nade_damage;
	setcefc(_nade, func_null);
	_nade.exteriormodeltoclient = NULL;
	_nade.traileffectnum = 0;
	_nade.teleportable = true;
	_nade.pushable = true;
	_nade.gravity = 1;
	_nade.missile_flags = MIF_SPLASH | MIF_ARC;
	_nade.damagedbycontents = true;
	_nade.angles = vectoangles(_nade.velocity);
	_nade.flags = FL_PROJECTILE;
	_nade.projectiledeathtype = DEATH_NADE.m_id;
	_nade.toss_time = time;
	_nade.solid = SOLID_CORPSE; //((_nade.nade_type == NADE_TYPE_TRANSLOCATE) ? SOLID_CORPSE : SOLID_BBOX);

	if(_nade.nade_type == NADE_TYPE_TRANSLOCATE.m_id || _nade.nade_type == NADE_TYPE_SPAWN.m_id)
		_nade.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_PLAYERCLIP | DPCONTENTS_BOTCLIP;
	else
		_nade.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_BODY;

	nade_spawn(_nade);

	if(_time)
	{
		setthink(_nade, nade_boom);
		_nade.nextthink = _time;
	}

	e.nade_refire = time + autocvar_g_nades_nade_refire;
	e.nade_timer = 0;
}

void nades_GiveBonus(entity player, float score)
{
	if (autocvar_g_nades)
	if (autocvar_g_nades_bonus)
	if (IS_REAL_CLIENT(player))
	if (IS_PLAYER(player) && player.bonus_nades < autocvar_g_nades_bonus_max)
	if (STAT(FROZEN, player) == 0)
	if (!IS_DEAD(player))
	{
		if ( player.bonus_nade_score < 1 )
			player.bonus_nade_score += score/autocvar_g_nades_bonus_score_max;

		if ( player.bonus_nade_score >= 1 )
		{
			Send_Notification(NOTIF_ONE, player, MSG_CENTER, CENTER_NADE_BONUS);
			play2(player, SND(KH_ALARM));
			player.bonus_nades++;
			player.bonus_nade_score -= 1;
		}
	}
}

/** Remove all bonus nades from a player */
void nades_RemoveBonus(entity player)
{
	player.bonus_nades = player.bonus_nade_score = 0;
}

MUTATOR_HOOKFUNCTION(nades, PutClientInServer)
{
    entity player = M_ARGV(0, entity);

	nades_RemoveBonus(player);
}

float nade_customize(entity this)
{
	//if(IS_SPEC(other)) { return false; }
	if(other == this.exteriormodeltoclient || (IS_SPEC(other) && other.enemy == this.exteriormodeltoclient))
	{
		// somewhat hide the model, but keep the glow
		//this.effects = 0;
		if(this.traileffectnum)
			this.traileffectnum = 0;
		this.alpha = -1;
	}
	else
	{
		//this.effects = EF_ADDITIVE | EF_FULLBRIGHT | EF_LOWPRECISION;
		if(!this.traileffectnum)
			this.traileffectnum = _particleeffectnum(Nade_TrailEffect(Nades_from(this.nade_type).m_projectile[false], this.team).eent_eff_name);
		this.alpha = 1;
	}

	return true;
}

void spawn_held_nade(entity player, entity nowner, float ntime, int ntype, string pntype)
{
	entity n = new(nade), fn = new(fake_nade);

	n.nade_type = max(1, ntype);
	n.pokenade_type = pntype;

	if(Nades_from(n.nade_type) == NADE_TYPE_Null)
		n.nade_type = NADE_TYPE_NORMAL.m_id;

	setmodel(n, MDL_PROJECTILE_NADE);
	//setattachment(n, player, "bip01 l hand");
	n.exteriormodeltoclient = player;
	setcefc(n, nade_customize);
	n.traileffectnum = _particleeffectnum(Nade_TrailEffect(Nades_from(n.nade_type).m_projectile[false], player.team).eent_eff_name);
	n.colormod = Nades_from(n.nade_type).m_color;
	n.realowner = nowner;
	n.colormap = player.colormap;
	n.glowmod = player.glowmod;
	n.wait = time + max(0, ntime);
	n.nade_time_primed = time;
	setthink(n, nade_beep);
	n.nextthink = max(n.wait - 3, time);
	n.projectiledeathtype = DEATH_NADE.m_id;

	setmodel(fn, MDL_NADE_VIEW);
	.entity weaponentity = weaponentities[0]; // TODO: unhardcode
	setattachment(fn, player.(weaponentity), "");
	fn.realowner = fn.owner = player;
	fn.colormod = Nades_from(n.nade_type).m_color;
	fn.colormap = player.colormap;
	fn.glowmod = player.glowmod;
	setthink(fn, SUB_Remove);
	fn.nextthink = n.wait;

	player.nade = n;
	player.fake_nade = fn;
}

void nade_prime(entity this)
{
	if(autocvar_g_nades_bonus_only)
	if(!this.bonus_nades)
		return; // only allow bonus nades

	if(this.nade)
		remove(this.nade);

	if(this.fake_nade)
		remove(this.fake_nade);

	int ntype;
	string pntype = this.pokenade_type;

	if(this.items & ITEM_Strength.m_itemid && autocvar_g_nades_bonus_onstrength)
		ntype = this.nade_type;
	else if (this.bonus_nades >= 1)
	{
		ntype = this.nade_type;
		pntype = this.pokenade_type;
		this.bonus_nades -= 1;
	}
	else
	{
		ntype = ((autocvar_g_nades_client_select) ? this.cvar_cl_nade_type : autocvar_g_nades_nade_type);
		pntype = ((autocvar_g_nades_client_select) ? this.cvar_cl_pokenade_type : autocvar_g_nades_pokenade_monster_type);
	}

	spawn_held_nade(this, this, autocvar_g_nades_nade_lifetime, ntype, pntype);
}

bool CanThrowNade(entity this)
{
	if(this.vehicle)
		return false;

	if(gameover)
		return false;

	if(IS_DEAD(this))
		return false;

	if (!autocvar_g_nades)
		return false; // allow turning them off mid match

	if(forbidWeaponUse(this))
		return false;

	if (!IS_PLAYER(this))
		return false;

	return true;
}

.bool nade_altbutton;

void nades_CheckThrow(entity this)
{
	if(!CanThrowNade(this))
		return;

	entity held_nade = this.nade;
	if (!held_nade)
	{
		this.nade_altbutton = true;
		if(time > this.nade_refire)
		{
			Send_Notification(NOTIF_ONE, this, MSG_CENTER, CENTER_NADE_THROW);
			nade_prime(this);
			this.nade_refire = time + autocvar_g_nades_nade_refire;
		}
	}
	else
	{
		this.nade_altbutton = false;
		if (time >= held_nade.nade_time_primed + 1) {
			makevectors(this.v_angle);
			float _force = time - held_nade.nade_time_primed;
			_force /= autocvar_g_nades_nade_lifetime;
			_force = autocvar_g_nades_nade_minforce + (_force * (autocvar_g_nades_nade_maxforce - autocvar_g_nades_nade_minforce));
			vector dir = (v_forward * 0.75 + v_up * 0.2 + v_right * 0.05);
			dir = W_CalculateSpread(dir, autocvar_g_nades_spread, g_weaponspreadfactor, autocvar_g_projectiles_spread_style);
			toss_nade(this, true, dir * _force, 0);
		}
	}
}

void nades_Clear(entity player)
{
	if(player.nade)
		remove(player.nade);
	if(player.fake_nade)
		remove(player.fake_nade);

	player.nade = player.fake_nade = NULL;
	player.nade_timer = 0;
}

MUTATOR_HOOKFUNCTION(nades, VehicleEnter)
{
	entity player = M_ARGV(0, entity);

	if(player.nade)
		toss_nade(player, true, '0 0 100', max(player.nade.wait, time + 0.05));
}

CLASS(NadeOffhand, OffhandWeapon)
    METHOD(NadeOffhand, offhand_think, void(NadeOffhand this, entity player, bool key_pressed))
    {
    	entity held_nade = player.nade;
		if (held_nade)
		{
			player.nade_timer = bound(0, (time - held_nade.nade_time_primed) / autocvar_g_nades_nade_lifetime, 1);
			// LOG_TRACEF("%d %d\n", player.nade_timer, time - held_nade.nade_time_primed);
			makevectors(player.angles);
			held_nade.velocity = player.velocity;
			setorigin(held_nade, player.origin + player.view_ofs + v_forward * 8 + v_right * -8 + v_up * 0);
			held_nade.angles_y = player.angles.y;

			if (time + 0.1 >= held_nade.wait)
				toss_nade(player, false, '0 0 0', time + 0.05);
		}

        if (!CanThrowNade(player)) return;
        if (!(time > player.nade_refire)) return;
		if (key_pressed) {
			if (!held_nade) {
				nade_prime(player);
				held_nade = player.nade;
			}
		} else if (time >= held_nade.nade_time_primed + 1) {
			if (held_nade) {
				makevectors(player.v_angle);
				float _force = time - held_nade.nade_time_primed;
				_force /= autocvar_g_nades_nade_lifetime;
				_force = autocvar_g_nades_nade_minforce + (_force * (autocvar_g_nades_nade_maxforce - autocvar_g_nades_nade_minforce));
				vector dir = (v_forward * 0.7 + v_up * 0.2 + v_right * 0.1);
				dir = W_CalculateSpread(dir, autocvar_g_nades_spread, g_weaponspreadfactor, autocvar_g_projectiles_spread_style);
				toss_nade(player, false, dir * _force, 0);
			}
		}
    }
ENDCLASS(NadeOffhand)
NadeOffhand OFFHAND_NADE; STATIC_INIT(OFFHAND_NADE) { OFFHAND_NADE = NEW(NadeOffhand); }

MUTATOR_HOOKFUNCTION(nades, ForbidThrowCurrentWeapon, CBC_ORDER_LAST)
{
    entity player = M_ARGV(0, entity);

	if (player.offhand != OFFHAND_NADE || (player.weapons & WEPSET(HOOK)) || autocvar_g_nades_override_dropweapon) {
		nades_CheckThrow(player);
		return true;
	}
}

MUTATOR_HOOKFUNCTION(nades, PlayerPreThink)
{
	entity player = M_ARGV(0, entity);

	if (!IS_PLAYER(player)) { return; }

	if (player.nade && (player.offhand != OFFHAND_NADE || (player.weapons & WEPSET(HOOK)))) OFFHAND_NADE.offhand_think(OFFHAND_NADE, player, player.nade_altbutton);

	if(IS_PLAYER(player))
	{
		if ( autocvar_g_nades_bonus && autocvar_g_nades )
		{
			entity key;
			float key_count = 0;
			FOR_EACH_KH_KEY(key) if(key.owner == player) { ++key_count; }

			float time_score;
			if(player.flagcarried || player.ballcarried) // this player is important
				time_score = autocvar_g_nades_bonus_score_time_flagcarrier;
			else
				time_score = autocvar_g_nades_bonus_score_time;

			if(key_count)
				time_score = autocvar_g_nades_bonus_score_time_flagcarrier * key_count; // multiply by the number of keys the player is holding

			if(autocvar_g_nades_bonus_client_select)
			{
				player.nade_type = player.cvar_cl_nade_type;
				player.pokenade_type = player.cvar_cl_pokenade_type;
			}
			else
			{
				player.nade_type = autocvar_g_nades_bonus_type;
				player.pokenade_type = autocvar_g_nades_pokenade_monster_type;
			}

			player.nade_type = bound(1, player.nade_type, Nades_COUNT);

			if(player.bonus_nade_score >= 0 && autocvar_g_nades_bonus_score_max)
				nades_GiveBonus(player, time_score / autocvar_g_nades_bonus_score_max);
		}
		else
		{
			player.bonus_nades = player.bonus_nade_score = 0;
		}
	}

	float n = 0;
	entity o = NULL;
	if(player.freezetag_frozen_timeout > 0 && time >= player.freezetag_frozen_timeout)
		n = -1;
	else
	{
		vector revive_extra_size = '1 1 1' * autocvar_g_freezetag_revive_extra_size;
		n = 0;
		FOREACH_CLIENT(IS_PLAYER(it) && it != player, LAMBDA(
			if(!IS_DEAD(it))
			if(STAT(FROZEN, it) == 0)
			if(SAME_TEAM(it, player))
			if(boxesoverlap(player.absmin - revive_extra_size, player.absmax + revive_extra_size, it.absmin, it.absmax))
			{
				if(!o)
					o = it;
				if(STAT(FROZEN, player) == 1)
					it.reviving = true;
				++n;
			}
		));
	}

	if(n && STAT(FROZEN, player) == 3) // OK, there is at least one teammate reviving us
	{
		player.revive_progress = bound(0, player.revive_progress + frametime * max(1/60, autocvar_g_freezetag_revive_speed), 1);
		player.health = max(1, player.revive_progress * start_health);

		if(player.revive_progress >= 1)
		{
			Unfreeze(player);

			Send_Notification(NOTIF_ONE, player, MSG_CENTER, CENTER_FREEZETAG_REVIVED, o.netname);
			Send_Notification(NOTIF_ONE, o, MSG_CENTER, CENTER_FREEZETAG_REVIVE, player.netname);
		}

		FOREACH_CLIENT(IS_PLAYER(it) && it.reviving, LAMBDA(
			it.revive_progress = player.revive_progress;
			it.reviving = false;
		));
	}
}

MUTATOR_HOOKFUNCTION(nades, PlayerPhysics)
{
	entity player = M_ARGV(0, entity);

	if (STAT(ENTRAP_ORB, player) > time)
	{
		player.stat_sv_maxspeed *= autocvar_g_nades_entrap_speed;
		player.stat_sv_airspeedlimit_nonqw *= autocvar_g_nades_entrap_speed;
	}
}

MUTATOR_HOOKFUNCTION(nades, MonsterMove)
{
    entity mon = M_ARGV(0, entity);

	if (STAT(ENTRAP_ORB, mon) > time)
	{
		M_ARGV(1, float) *= autocvar_g_nades_entrap_speed; // run speed
		M_ARGV(2, float) *= autocvar_g_nades_entrap_speed; // walk speed
	}
}

MUTATOR_HOOKFUNCTION(nades, PlayerSpawn)
{
	entity player = M_ARGV(0, entity);

	if(autocvar_g_nades_spawn)
		player.nade_refire = time + autocvar_g_spawnshieldtime;
	else
		player.nade_refire  = time + autocvar_g_nades_nade_refire;

	if(autocvar_g_nades_bonus_client_select)
		player.nade_type = player.cvar_cl_nade_type;

	player.nade_timer = 0;

	if (!player.offhand) player.offhand = OFFHAND_NADE;

	if(player.nade_spawnloc)
	{
		setorigin(player, player.nade_spawnloc.origin);
		player.nade_spawnloc.cnt -= 1;

		if(player.nade_spawnloc.cnt <= 0)
		{
			remove(player.nade_spawnloc);
			player.nade_spawnloc = NULL;
		}
	}
}

MUTATOR_HOOKFUNCTION(nades, PlayerDies, CBC_ORDER_LAST)
{
	entity frag_attacker = M_ARGV(1, entity);
	entity frag_target = M_ARGV(2, entity);

	if(frag_target.nade)
	if(!STAT(FROZEN, frag_target) || !autocvar_g_freezetag_revive_nade)
		toss_nade(frag_target, true, '0 0 100', max(frag_target.nade.wait, time + 0.05));

	float killcount_bonus = ((frag_attacker.killcount >= 1) ? bound(0, autocvar_g_nades_bonus_score_minor * frag_attacker.killcount, autocvar_g_nades_bonus_score_medium) : autocvar_g_nades_bonus_score_minor);

	if(IS_PLAYER(frag_attacker))
	{
		if (SAME_TEAM(frag_attacker, frag_target) || frag_attacker == frag_target)
			nades_RemoveBonus(frag_attacker);
		else if(frag_target.flagcarried)
			nades_GiveBonus(frag_attacker, autocvar_g_nades_bonus_score_medium);
		else if(autocvar_g_nades_bonus_score_spree && frag_attacker.killcount > 1)
		{
			#define SPREE_ITEM(counta,countb,center,normal,gentle) \
				case counta: { nades_GiveBonus(frag_attacker, autocvar_g_nades_bonus_score_spree); break; }
			switch(frag_attacker.killcount)
			{
				KILL_SPREE_LIST
				default: nades_GiveBonus(frag_attacker, autocvar_g_nades_bonus_score_minor); break;
			}
			#undef SPREE_ITEM
		}
		else
			nades_GiveBonus(frag_attacker, killcount_bonus);
	}

	nades_RemoveBonus(frag_target);
}

MUTATOR_HOOKFUNCTION(nades, PlayerDamage_Calculate)
{
	entity frag_inflictor = M_ARGV(0, entity);
	entity frag_attacker = M_ARGV(1, entity);
	entity frag_target = M_ARGV(2, entity);
	float frag_deathtype = M_ARGV(3, float);

	if(STAT(FROZEN, frag_target))
	if(autocvar_g_freezetag_revive_nade)
	if(frag_attacker == frag_target)
	if(frag_deathtype == DEATH_NADE.m_id)
	if(time - frag_inflictor.toss_time <= 0.1)
	{
		Unfreeze(frag_target);
		frag_target.health = autocvar_g_freezetag_revive_nade_health;
		Send_Effect(EFFECT_ICEORGLASS, frag_target.origin, '0 0 0', 3);
		M_ARGV(4, float) = 0;
		M_ARGV(6, vector) = '0 0 0';
		Send_Notification(NOTIF_ALL, NULL, MSG_INFO, INFO_FREEZETAG_REVIVED_NADE, frag_target.netname);
		Send_Notification(NOTIF_ONE, frag_target, MSG_CENTER, CENTER_FREEZETAG_REVIVE_SELF);
	}
}

MUTATOR_HOOKFUNCTION(nades, MonsterDies)
{
	entity frag_target = M_ARGV(0, entity);
	entity frag_attacker = M_ARGV(1, entity);

	if(IS_PLAYER(frag_attacker))
	if(DIFF_TEAM(frag_attacker, frag_target))
	if(!(frag_target.spawnflags & MONSTERFLAG_SPAWNED))
		nades_GiveBonus(frag_attacker, autocvar_g_nades_bonus_score_minor);
}

MUTATOR_HOOKFUNCTION(nades, DropSpecialItems)
{
	entity frag_target = M_ARGV(0, entity);
	
	if(frag_target.nade)
		toss_nade(frag_target, true, '0 0 0', time + 0.05);
}

void nades_RemovePlayer(entity this)
{
	nades_Clear(this);
	nades_RemoveBonus(this);
}

MUTATOR_HOOKFUNCTION(nades, MakePlayerObserver) { entity player = M_ARGV(0, entity); nades_RemovePlayer(player); }
MUTATOR_HOOKFUNCTION(nades, ClientDisconnect) { entity player = M_ARGV(0, entity); nades_RemovePlayer(player); }
MUTATOR_HOOKFUNCTION(nades, reset_map_global)
{
	FOREACH_CLIENT(IS_PLAYER(it),
	{
		nades_RemovePlayer(it);
	});
}

MUTATOR_HOOKFUNCTION(nades, SpectateCopy)
{
	entity spectatee = M_ARGV(0, entity);
	entity client = M_ARGV(1, entity);

	client.nade_timer = spectatee.nade_timer;
	client.nade_type = spectatee.nade_type;
	client.pokenade_type = spectatee.pokenade_type;
	client.bonus_nades = spectatee.bonus_nades;
	client.bonus_nade_score = spectatee.bonus_nade_score;
	client.stat_healing_orb = spectatee.stat_healing_orb;
	client.stat_healing_orb_alpha = spectatee.stat_healing_orb_alpha;
	STAT(ENTRAP_ORB, client) = STAT(ENTRAP_ORB, spectatee);
	STAT(ENTRAP_ORB_ALPHA, client) = STAT(ENTRAP_ORB_ALPHA, spectatee);
}

REPLICATE(cvar_cl_nade_type, int, "cl_nade_type");
REPLICATE(cvar_cl_pokenade_type, string, "cl_pokenade_type");

MUTATOR_HOOKFUNCTION(nades, BuildMutatorsString)
{
	M_ARGV(0, string) = strcat(M_ARGV(0, string), ":Nades");
}

MUTATOR_HOOKFUNCTION(nades, BuildMutatorsPrettyString)
{
	M_ARGV(0, string) = strcat(M_ARGV(0, string), ", Nades");
}

MUTATOR_HOOKFUNCTION(nades, BuildGameplayTipsString)
{
	M_ARGV(0, string) = strcat(M_ARGV(0, string), "\n\n^3nades^8 are enabled, press 'g' to use them\n");
}

#endif
#endif
