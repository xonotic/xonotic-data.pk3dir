#pragma once

CLASS(Electro, Weapon)
/* spawnfunc */ ATTRIB(Electro, m_canonical_spawnfunc, string, "weapon_electro");
/* ammotype  */ ATTRIB(Electro, ammo_type, Resource, RES_CELLS);
/* impulse   */ ATTRIB(Electro, impulse, int, 5);
/* flags     */ ATTRIB(Electro, spawnflags, int, WEP_FLAG_NORMAL | WEP_FLAG_RELOADABLE | WEP_TYPE_SPLASH);
/* rating    */ ATTRIB(Electro, bot_pickupbasevalue, float, 5000);
/* color     */ ATTRIB(Electro, wpcolor, vector, '0 0.5 1');
/* modelname */ ATTRIB(Electro, mdl, string, "electro");
#ifdef GAMEQC
/* model     */ ATTRIB(Electro, m_model, Model, MDL_ELECTRO_ITEM);
/* flash mdl */ ATTRIB(Electro, m_muzzlemodel, Model, MDL_Null);
/* flash eff */ ATTRIB(Electro, m_muzzleeffect, entity, EFFECT_ELECTRO_MUZZLEFLASH);
#endif
/* crosshair */ ATTRIB(Electro, w_crosshair, string, "gfx/crosshairelectro");
/* crosshair */ ATTRIB(Electro, w_crosshair_size, float, 0.6);
/* wepimg    */ ATTRIB(Electro, model2, string, "weaponelectro");
/* refname   */ ATTRIB(Electro, netname, string, "electro");
/* wepname   */ ATTRIB(Electro, m_name, string, _("Electro"));

#define X(BEGIN, P, END, class, prefix) \
	BEGIN(class) \
		P(class, prefix, ammo, float, BOTH) \
		P(class, prefix, animtime, float, BOTH) \
		P(class, prefix, bouncefactor, float, SEC) \
		P(class, prefix, bouncestop, float, SEC) \
		P(class, prefix, comboradius, float, PRI) \
		P(class, prefix, combo_comboradius, float, NONE) \
		P(class, prefix, combo_comboradius_thruwall, float, NONE) \
		P(class, prefix, combo_damage, float, NONE) \
		P(class, prefix, combo_duration, float, NONE) \
		P(class, prefix, combo_edgedamage, float, NONE) \
		P(class, prefix, combo_force, float, NONE) \
		P(class, prefix, combo_radius, float, NONE) \
		P(class, prefix, combo_safeammocheck, float, NONE) \
		P(class, prefix, combo_speed, float, NONE) \
		P(class, prefix, count, float, SEC) \
		P(class, prefix, damagedbycontents, float, SEC) \
		P(class, prefix, damageforcescale, float, SEC) \
		P(class, prefix, damage, float, BOTH) \
		P(class, prefix, edgedamage, float, BOTH) \
		P(class, prefix, force, float, BOTH) \
		P(class, prefix, health, float, SEC) \
		P(class, prefix, lifetime, float, BOTH) \
		P(class, prefix, limit, float, SEC) \
		P(class, prefix, midaircombo_enemy, bool, PRI) \
		P(class, prefix, midaircombo_explode, float, PRI) \
		P(class, prefix, midaircombo_interval, float, PRI) \
		P(class, prefix, midaircombo_own, bool, PRI) \
		P(class, prefix, midaircombo_radius, float, PRI) \
		P(class, prefix, midaircombo_speed, float, PRI) \
		P(class, prefix, midaircombo_teammate, float, PRI) \
		P(class, prefix, radius, float, BOTH) \
		P(class, prefix, refire2, float, SEC) \
		P(class, prefix, refire, float, BOTH) \
		P(class, prefix, reload_ammo, float, NONE) \
		P(class, prefix, reload_time, float, NONE) \
		P(class, prefix, speed, float, BOTH) \
		P(class, prefix, speed_up, float, SEC) \
		P(class, prefix, speed_z, float, SEC) \
		P(class, prefix, spread, float, BOTH) \
		P(class, prefix, stick, float, SEC) \
		P(class, prefix, stick_lifetime, float, SEC) \
		P(class, prefix, switchdelay_drop, float, NONE) \
		P(class, prefix, switchdelay_raise, float, NONE) \
		P(class, prefix, touchexplode, float, SEC) \
		P(class, prefix, weaponreplace, string,NONE) \
		P(class, prefix, weaponstartoverride, float, NONE) \
		P(class, prefix, weaponstart, float, NONE) \
		P(class, prefix, weaponthrowable, float, NONE) \
	END()
	W_PROPS(X, Electro, electro)
#undef X

ENDCLASS(Electro)
REGISTER_WEAPON(ELECTRO, NEW(Electro));

SPAWNFUNC_WEAPON(weapon_electro, WEP_ELECTRO)

#ifdef SVQC
IntrusiveList LimitedElectroBallRubbleList;
.float electro_count;
.float electro_secondarytime;
void W_Electro_ExplodeCombo(entity this);
#endif

#ifdef CSQC
bool autocvar_cl_polytrails_electro_bolt = true;
float autocvar_cl_polytrails_electro_bolt_head_alpha = 1;
vector autocvar_cl_polytrails_electro_bolt_head_color = '0.75 0.75 1';
float autocvar_cl_polytrails_electro_bolt_head_thickness = 5;
float autocvar_cl_polytrails_electro_bolt_body_alpha = 0.5;
vector autocvar_cl_polytrails_electro_bolt_body_color = '0.45 0.45 1';
float autocvar_cl_polytrails_electro_bolt_body_thickness = 5;
float autocvar_cl_polytrails_electro_bolt_tail_alpha = 0;
vector autocvar_cl_polytrails_electro_bolt_tail_color = '0.1 0.1 0.75';
float autocvar_cl_polytrails_electro_bolt_tail_thickness = 0;
float autocvar_cl_polytrails_electro_bolt_lifetime = 0.27;
float autocvar_cl_polytrails_electro_bolt_segmentsize = 10;
float autocvar_cl_polytrails_electro_bolt_noise = 5;
string autocvar_cl_polytrails_electro_bolt_noisefunc = "chaotic";
CLASS(ElectroBoltTrail, PolyTrail)
	ATTRIB(ElectroBoltTrail, polytrail_tex, string, "particles/lgbeam.tga");
	ATTRIB(ElectroBoltTrail, polytrail_lifetime, float, autocvar_cl_polytrails_electro_bolt_lifetime);
	ATTRIB(ElectroBoltTrail, polytrail_noise, float, autocvar_cl_polytrails_electro_bolt_noise);
	ATTRIB(ElectroBoltTrail, polytrail_segmentsize, float, autocvar_cl_polytrails_electro_bolt_segmentsize);
	ATTRIB(ElectroBoltTrail, polytrail_noisefunc, string, autocvar_cl_polytrails_electro_bolt_noisefunc);
	ATTRIB(ElectroBoltTrail, polytrail_head_alpha, float, autocvar_cl_polytrails_electro_bolt_head_alpha);
	ATTRIB(ElectroBoltTrail, polytrail_head_color, vector, autocvar_cl_polytrails_electro_bolt_head_color);
	ATTRIB(ElectroBoltTrail, polytrail_head_thickness, float, autocvar_cl_polytrails_electro_bolt_head_thickness);
	ATTRIB(ElectroBoltTrail, polytrail_body_alpha, float, autocvar_cl_polytrails_electro_bolt_body_alpha);
	ATTRIB(ElectroBoltTrail, polytrail_body_color, vector, autocvar_cl_polytrails_electro_bolt_body_color);
	ATTRIB(ElectroBoltTrail, polytrail_body_thickness, float, autocvar_cl_polytrails_electro_bolt_body_thickness);
	ATTRIB(ElectroBoltTrail, polytrail_tail_alpha, float, autocvar_cl_polytrails_electro_bolt_tail_alpha);
	ATTRIB(ElectroBoltTrail, polytrail_tail_color, vector, autocvar_cl_polytrails_electro_bolt_tail_color);
	ATTRIB(ElectroBoltTrail, polytrail_tail_thickness, float, autocvar_cl_polytrails_electro_bolt_tail_thickness);
ENDCLASS(ElectroBoltTrail)

bool autocvar_cl_polytrails_electro_orb = true;
float autocvar_cl_polytrails_electro_orb_head_alpha = 1;
vector autocvar_cl_polytrails_electro_orb_head_color = '0.8 0.8 1';
float autocvar_cl_polytrails_electro_orb_head_thickness = 15;
float autocvar_cl_polytrails_electro_orb_body_alpha = 0.5;
vector autocvar_cl_polytrails_electro_orb_body_color = '0.5 0.5 1';
float autocvar_cl_polytrails_electro_orb_body_thickness = 7;
float autocvar_cl_polytrails_electro_orb_tail_alpha = 0;
vector autocvar_cl_polytrails_electro_orb_tail_color = '0.1 0.1 0.7';
float autocvar_cl_polytrails_electro_orb_tail_thickness = 0;
float autocvar_cl_polytrails_electro_orb_lifetime = 0.18;
float autocvar_cl_polytrails_electro_orb_segmentsize = 10;
float autocvar_cl_polytrails_electro_orb_noise = 10;
string autocvar_cl_polytrails_electro_orb_noisefunc = "chaotic";
CLASS(ElectroOrbTrail, PolyTrail)
	ATTRIB(ElectroOrbTrail, polytrail_tex, string, "particles/lgbeam.tga");
	ATTRIB(ElectroOrbTrail, polytrail_lifetime, float, autocvar_cl_polytrails_electro_orb_lifetime);
	ATTRIB(ElectroOrbTrail, polytrail_noise, float, autocvar_cl_polytrails_electro_orb_noise);
	ATTRIB(ElectroOrbTrail, polytrail_segmentsize, float, autocvar_cl_polytrails_electro_orb_segmentsize);
	ATTRIB(ElectroOrbTrail, polytrail_noisefunc, string, autocvar_cl_polytrails_electro_orb_noisefunc);
	ATTRIB(ElectroOrbTrail, polytrail_head_alpha, float, autocvar_cl_polytrails_electro_orb_head_alpha);
	ATTRIB(ElectroOrbTrail, polytrail_head_color, vector, autocvar_cl_polytrails_electro_orb_head_color);
	ATTRIB(ElectroOrbTrail, polytrail_head_thickness, float, autocvar_cl_polytrails_electro_orb_head_thickness);
	ATTRIB(ElectroOrbTrail, polytrail_body_alpha, float, autocvar_cl_polytrails_electro_orb_body_alpha);
	ATTRIB(ElectroOrbTrail, polytrail_body_color, vector, autocvar_cl_polytrails_electro_orb_body_color);
	ATTRIB(ElectroOrbTrail, polytrail_body_thickness, float, autocvar_cl_polytrails_electro_orb_body_thickness);
	ATTRIB(ElectroOrbTrail, polytrail_tail_alpha, float, autocvar_cl_polytrails_electro_orb_tail_alpha);
	ATTRIB(ElectroOrbTrail, polytrail_tail_color, vector, autocvar_cl_polytrails_electro_orb_tail_color);
	ATTRIB(ElectroOrbTrail, polytrail_tail_thickness, float, autocvar_cl_polytrails_electro_orb_tail_thickness);
ENDCLASS(ElectroOrbTrail)
#endif
