#ifndef NOTIFICATIONS_H
#define NOTIFICATIONS_H

#include "constants.qh"
#include "teams.qh"
#include "util.qh"

// ================================================
//  Unified notification system, written by Samual
//  Last updated: March, 2013
// ================================================

// main types/groups of notifications
const int MSG_ANNCE = 1; // "Global" AND "personal" announcer messages
const int MSG_INFO = 2; // "Global" information messages
const int MSG_CENTER = 3; // "Personal" centerprint messages
const int MSG_CENTER_CPID = 4; // Kill centerprint message
const int MSG_MULTI = 5; // Subcall MSG_INFO and/or MSG_CENTER notifications
const int MSG_CHOICE = 6; // Choose which subcall wrapper to activate

// negative confirmations
const int NO_MSG = -12345;  // allows various things to know when no information is added
const int NOTIF_ABORT = -1234;   // allows Send_Notification to safely abort sending

#define EIGHT_VARS_TO_VARARGS_VARLIST \
    VARITEM(1, 0, s1) \
    VARITEM(2, 0, XPD(s1, s2)) \
    VARITEM(3, 0, XPD(s1, s2, s3)) \
    VARITEM(4, 0, XPD(s1, s2, s3, s4)) \
    VARITEM(0, 1, f1) \
    VARITEM(1, 1, XPD(s1, f1)) \
    VARITEM(2, 1, XPD(s1, s2, f1)) \
    VARITEM(3, 1, XPD(s1, s2, s3, f1)) \
    VARITEM(4, 1, XPD(s1, s2, s3, s4, f1)) \
    VARITEM(0, 2, XPD(f1, f2)) \
    VARITEM(1, 2, XPD(s1, f1, f2)) \
    VARITEM(2, 2, XPD(s1, s2, f1, f2)) \
    VARITEM(3, 2, XPD(s1, s2, s3, f1, f2)) \
    VARITEM(4, 2, XPD(s1, s2, s3, s4, f1, f2)) \
    VARITEM(0, 3, XPD(f1, f2, f3)) \
    VARITEM(1, 3, XPD(s1, f1, f2, f3)) \
    VARITEM(2, 3, XPD(s1, s2, f1, f2, f3)) \
    VARITEM(3, 3, XPD(s1, s2, s3, f1, f2, f3)) \
    VARITEM(4, 3, XPD(s1, s2, s3, s4, f1, f2, f3)) \
    VARITEM(0, 4, XPD(f1, f2, f3, f4)) \
    VARITEM(1, 4, XPD(s1, f1, f2, f3, f4)) \
    VARITEM(2, 4, XPD(s1, s2, f1, f2, f3, f4)) \
    VARITEM(3, 4, XPD(s1, s2, s3, f1, f2, f3, f4)) \
    VARITEM(4, 4, XPD(s1, s2, s3, s4, f1, f2, f3, f4))

void Destroy_All_Notifications(void);
void Create_Notification_Entity(
    float var_default,
    float var_cvar,
    float typeId,
    float nameid,
    string namestring,
    int strnum,
    int flnum,
    /* MSG_ANNCE */
    float channel,
    string snd,
    float vol,
    float position,
    /* MSG_INFO & MSG_CENTER */
    string args,
    string hudargs,
    string icon,
    float cpid,
    string durcnt,
    string normal,
    string gentle,
    /* MSG_MULTI */
    float anncename,
    float infoname,
    float centername,
    /* MSG_CHOICE */
    float challow_def,
    float challow_var,
    float chtype,
    float optiona,
    float optionb);

void Dump_Notifications(float fh, float alsoprint);

#ifdef NOTIFICATIONS_DEBUG
void Debug_Notification(string input);
#endif

void Local_Notification(int net_type, int net_name, ...count);
void Local_Notification_WOVA(
    float net_type, float net_name,
    float stringcount, float floatcount,
    string s1, string s2, string s3, string s4,
    float f1, float f2, float f3, float f4);

#ifdef CSQC // CLIENT ONLY
void Read_Notification(float is_new);
string prev_soundfile;
float prev_soundtime;
#endif

#ifdef SVQC // SERVER ONLY
const float NOTIF_ONE = 1;
const float NOTIF_ONE_ONLY = 2;
const float NOTIF_TEAM = 3;
const float NOTIF_TEAM_EXCEPT = 4;
const float NOTIF_ALL = 5;
const float NOTIF_ALL_EXCEPT = 6;

void Kill_Notification(
    float broadcast, entity client,
    float net_type, float net_name);
void Send_Notification(
    float broadcast, entity client,
    float net_type, float net_name,
    ...count);
void Send_Notification_WOVA(
    float broadcast, entity client,
    float net_type, float net_name,
    float stringcount, float floatcount,
    string s1, string s2, string s3, string s4,
    float f1, float f2, float f3, float f4);
void Send_Notification_WOCOVA(
    float broadcast, entity client,
    float net_type, float net_name,
    string s1, string s2, string s3, string s4,
    float f1, float f2, float f3, float f4);
#endif

// ===========================
//  Special CVAR Declarations
// ===========================

// MAKE SURE THIS IS ALWAYS SYNCHRONIZED WITH THE DUMP
// NOTIFICATIONS FUNCTION IN THE .QC FILE!

#define NOTIF_ADD_AUTOCVAR(name,default) float autocvar_notification_##name = default;

float autocvar_notification_show_location = false;
string autocvar_notification_show_location_string = ""; //_(" at the %s");
float autocvar_notification_show_sprees = true;
float autocvar_notification_show_sprees_info = 3; // 0 = off, 1 = target only, 2 = attacker only, 3 = target and attacker
float autocvar_notification_show_sprees_info_newline = true;
float autocvar_notification_show_sprees_info_specialonly = true;
float autocvar_notification_errors_are_fatal = true;
float autocvar_notification_lifetime_runtime = 0.5;
float autocvar_notification_lifetime_mapload = 10;
float autocvar_notification_debug = false;

#ifdef SVQC
.float FRAG_VERBOSE;
void Notification_GetCvars(void);
float autocvar_notification_server_allows_location = 1; // 0 = no, 1 = yes
#else
float autocvar_notification_item_centerprinttime = 1.5;

// 0 = no, 1 = yes, 2 = forced on for all MSG_INFO notifs
// DISABLED IN CODE, BUT ENABLED IN CONFIG FOR COMPATIBILITY WITH OLD CLIENTS
float autocvar_notification_allow_chatboxprint = 0;

float autocvar_notification_show_sprees_center = true;
float autocvar_notification_show_sprees_center_specialonly = true;
#endif


// ============================
//  Notification Argument List
// ============================
/*
 These arguments get replaced with the Local_Notification_sprintf
 and other such functions found in notifications.qc to supply data
 from networked notifications to their usage in sprintf... It
 allows for more dynamic data to be inferred by the local
 notification parser, so that the server does not have to network
 anything too crazy on a per-client/per-situation basis.

 Pay attention to the CSQC/SVQC relations, some of these are redefined
 in slightly different ways for different programs, this is because the
 server does a more conservative approach to the notifs than the client.

 All arguments are swapped into strings, so be sure that your
 sprintf usage matches with proper %s placement.

 Argument descriptions:
    s1-s4: string arguments to be literally swapped into sprintf
    s2loc: s2 string of locations of deaths or other events
    s3loc: s3 string of locations of deaths or other events
    f1-f4: float arguments expanded into strings to be swapped into sprintf
    f1p2dec: f1 float to string with 2 decimal places
    f2p2dec: f2 float to string with 2 decimal places
    f2primsec: f2 float primary or secondary selection for weapons
    f3primsec: f3 float primary or secondary selection for weapons
    f1secs: count_seconds of f1
    f1ord: count_ordinal of f1
    f1time: process_time of f1
    f1race_time: mmssss of f1
    f2race_time: mmssss of f2
    race_col: color of race time/position (i.e. good or bad)
    race_diff: show time difference between f2 and f3
    missing_teams: show which teams still need players
    pass_key: find the keybind for "passing" or "dropping" in CTF game mode
    frag_ping: show the ping of a player
    frag_stats: show health/armor/ping of a player
    frag_pos: show score status and position in the match of a player
    spree_cen: centerprint notif for kill spree/how many kills they have
    spree_inf: info notif for kill spree/how many kills they have
    spree_end: placed at the end of murder messages to show ending of sprees
    spree_lost: placed at the end of suicide messages to show losing of sprees
    item_wepname: return full name of a weapon from weaponid
    item_wepammo: ammo display for weapon from string
    item_centime: amount of time to display weapon message in centerprint
    item_buffname: return full name of a buff from buffid
    death_team: show the full name of the team a player is switching from
    minigame1_name: return human readable name of a minigame from its id(s1)
    minigame1_d: return descriptor name of a minigame from its id(s1)
*/

const float NOTIF_MAX_ARGS = 7;
const float NOTIF_MAX_HUDARGS = 2;
const float NOTIF_MAX_DURCNT = 2;

string arg_slot[NOTIF_MAX_ARGS];

const float ARG_CS_SV_HA = 1; // enabled on CSQC, SVQC, and Hudargs
const float ARG_CS_SV_DC = 2; // enabled on CSQC, SVQC, and durcnt centerprint
const float ARG_CS_SV = 3; // enabled on CSQC and SVQC
const float ARG_CS = 4; // unique result to CSQC
const float ARG_SV = 5; // unique result to SVQC
const float ARG_DC = 6; // unique result to durcnt/centerprint

// todo possible idea.... declare how many floats/strings each arg needs, and then dynamically increment the input
// this way, we don't need to have duplicates like i.e. s2loc and s3loc?

#define NOTIF_ARGUMENT_LIST \
    ARG_CASE(ARG_CS_SV_HA,  "s1",            s1) \
    ARG_CASE(ARG_CS_SV_HA,  "s2",            s2) \
    ARG_CASE(ARG_CS_SV_HA,  "s3",            s3) \
    ARG_CASE(ARG_CS_SV_HA,  "s4",            s4) \
    ARG_CASE(ARG_CS_SV,     "s2loc",         ((autocvar_notification_show_location && (s2 != "")) ? sprintf(( ((tmp_s = autocvar_notification_show_location_string) != "") ? tmp_s : _(" (near %s)") ), s2) : "")) \
    ARG_CASE(ARG_CS_SV,     "s3loc",         ((autocvar_notification_show_location && (s3 != "")) ? sprintf(( ((tmp_s = autocvar_notification_show_location_string) != "") ? tmp_s : _(" (near %s)") ), s3) : "")) \
    ARG_CASE(ARG_CS_SV_DC,  "f1",            ftos(f1)) \
    ARG_CASE(ARG_CS_SV_DC,  "f2",            ftos(f2)) \
    ARG_CASE(ARG_CS_SV,     "f3",            ftos(f3)) \
    ARG_CASE(ARG_CS_SV,     "f4",            ftos(f4)) \
    ARG_CASE(ARG_CS_SV,     "f1p2dec",       ftos_decimals(f1/100, 2)) \
    ARG_CASE(ARG_CS_SV,     "f2p2dec",       ftos_decimals(f2/100, 2)) \
    ARG_CASE(ARG_CS,        "f2primsec",     (f2 ? _("secondary") : _("primary"))) \
    ARG_CASE(ARG_CS,        "f3primsec",     (f3 ? _("secondary") : _("primary"))) \
    ARG_CASE(ARG_CS,        "f1secs",        count_seconds(f1)) \
    ARG_CASE(ARG_CS_SV,     "f1ord",         count_ordinal(f1)) \
    ARG_CASE(ARG_CS,        "f1time",        process_time(2, f1)) \
    ARG_CASE(ARG_CS_SV_HA,  "f1race_time",   mmssss(f1)) \
    ARG_CASE(ARG_CS_SV_HA,  "f2race_time",   mmssss(f2)) \
    ARG_CASE(ARG_CS_SV_HA,  "f3race_time",   mmssss(f3)) \
    ARG_CASE(ARG_CS_SV,     "race_col",      CCR(((f1 == 1) ? "^F1" : "^F2"))) \
    ARG_CASE(ARG_CS_SV,     "race_diff",     ((f2 > f3) ? sprintf(CCR("^1[+%s]"), mmssss(f2 - f3)) : sprintf(CCR("^2[-%s]"), mmssss(f3 - f2)))) \
    ARG_CASE(ARG_CS,        "missing_teams", notif_arg_missing_teams(f1)) \
    ARG_CASE(ARG_CS,        "pass_key",      ((((tmp_s = getcommandkey("pass", "+use")) != "pass") && !(strstrofs(tmp_s, "not bound", 0) >= 0)) ? sprintf(CCR(_(" ^F1(Press %s)")), tmp_s) : "")) \
    ARG_CASE(ARG_CS,        "frag_ping",     notif_arg_frag_ping(true, f2)) \
    ARG_CASE(ARG_CS,        "frag_stats",    notif_arg_frag_stats(f2, f3, f4)) \
    /*ARG_CASE(ARG_CS,      "frag_pos",      ((Should_Print_Score_Pos(f1)) ? sprintf("\n^BG%s", Read_Score_Pos(f1)) : ""))*/ \
    ARG_CASE(ARG_CS,        "spree_cen",     (autocvar_notification_show_sprees ? notif_arg_spree_cen(f1) : "")) \
    ARG_CASE(ARG_CS_SV,     "spree_inf",     (autocvar_notification_show_sprees ? notif_arg_spree_inf(1, input, s2, f2) : "")) \
    ARG_CASE(ARG_CS_SV,     "spree_end",     (autocvar_notification_show_sprees ? notif_arg_spree_inf(-1, "", "", f1) : "")) \
    ARG_CASE(ARG_CS_SV,     "spree_lost",    (autocvar_notification_show_sprees ? notif_arg_spree_inf(-2, "", "", f1) : "")) \
    ARG_CASE(ARG_CS_SV,     "item_wepname",  WEP_NAME(f1)) \
    ARG_CASE(ARG_CS_SV,     "item_buffname", sprintf("%s%s", rgb_to_hexcolor(BUFFS[f1].m_color), BUFFS[f1].m_prettyName)) \
    ARG_CASE(ARG_CS_SV,     "f3buffname",    sprintf("%s%s", rgb_to_hexcolor(BUFFS[f3].m_color), BUFFS[f3].m_prettyName)) \
    ARG_CASE(ARG_CS_SV,     "item_wepammo",  (s1 != "" ? sprintf(_(" with %s"), s1) : "")) \
    ARG_CASE(ARG_DC,        "item_centime",  ftos(autocvar_notification_item_centerprinttime)) \
    ARG_CASE(ARG_SV,        "death_team",    Team_ColoredFullName(f1)) \
    ARG_CASE(ARG_CS,        "death_team",    Team_ColoredFullName(f1 - 1)) \
    ARG_CASE(ARG_CS_SV_HA,  "minigame1_name",find(world,netname,s1).descriptor.message) \
    ARG_CASE(ARG_CS_SV_HA,  "minigame1_d",   find(world,netname,s1).descriptor.netname)

#define NOTIF_HIT_MAX(count,funcname) do { \
    if(sel_num == count) { backtrace(sprintf("%s: Hit maximum arguments!\n", funcname)); break; } \
} while(0)
#define NOTIF_HIT_UNKNOWN(token,funcname) { backtrace(sprintf("%s: Hit unknown token in selected string! '%s'\n", funcname, selected)); break; }

#define KILL_SPREE_LIST \
    SPREE_ITEM(3, 03, _("TRIPLE FRAG! "), _("%s^K1 made a TRIPLE FRAG! %s^BG"), _("%s^K1 made a TRIPLE SCORE! %s^BG")) \
    SPREE_ITEM(5, 05, _("RAGE! "), _("%s^K1 unlocked RAGE! %s^BG"), _("%s^K1 made FIVE SCORES IN A ROW! %s^BG")) \
    SPREE_ITEM(10, 10, _("MASSACRE! "), _("%s^K1 started a MASSACRE! %s^BG"), _("%s^K1 made TEN SCORES IN A ROW! %s^BG")) \
    SPREE_ITEM(15, 15, _("MAYHEM! "), _("%s^K1 executed MAYHEM! %s^BG"), _("%s^K1 made FIFTEEN SCORES IN A ROW! %s^BG")) \
    SPREE_ITEM(20, 20, _("BERSERKER! "), _("%s^K1 is a BERSERKER! %s^BG"), _("%s^K1 made TWENTY SCORES IN A ROW! %s^BG")) \
    SPREE_ITEM(25, 25, _("CARNAGE! "), _("%s^K1 inflicts CARNAGE! %s^BG"), _("%s^K1 made TWENTY FIVE SCORES IN A ROW! %s^BG")) \
    SPREE_ITEM(30, 30, _("ARMAGEDDON! "), _("%s^K1 unleashes ARMAGEDDON! %s^BG"), _("%s^K1 made THIRTY SCORES IN A ROW! %s^BG"))

#ifdef CSQC
string notif_arg_frag_ping(float newline, float fping)
{
    if(fping == NO_MSG)
        return sprintf(CCR(_("%s(^F1Bot^BG)")), (newline ? "\n" : " "));
    else
        return sprintf(CCR(_("%s(Ping ^F1%d^BG)")), (newline ? "\n" : " "), fping);
}

string notif_arg_frag_stats(float fhealth, float farmor, float fping)
{
    if (!(fhealth < 1))
        return sprintf(CCR(_("\n(Health ^1%d^BG / Armor ^2%d^BG)%s")), fhealth, farmor, notif_arg_frag_ping(false, fping));
    else
        return sprintf(CCR(_("\n(^F4Dead^BG)%s")), notif_arg_frag_ping(false, fping));
}

string notif_arg_missing_teams(float f1)
{
    return sprintf("%s%s%s%s",
        ((f1 & 1) ?
            sprintf("%s%s", Team_ColoredFullName(NUM_TEAM_1), ((f1 & (2 + 4 + 8)) ? ", " : ""))
            :
            ""
        ),
        ((f1 & 2) ?
            sprintf("%s%s", Team_ColoredFullName(NUM_TEAM_2), ((f1 & (4 + 8)) ? ", " : ""))
            :
            ""
        ),
        ((f1 & 4) ?
            sprintf("%s%s", Team_ColoredFullName(NUM_TEAM_3), ((f1 & 8) ? ", " : ""))
            :
            ""
        ),
        ((f1 & 8) ?
            Team_ColoredFullName(NUM_TEAM_4)
            :
            ""
        )
    );
}

string notif_arg_spree_cen(float spree)
{
    // 0 = off, 1 = target (but only for first victim) and attacker
    if(autocvar_notification_show_sprees_center)
    {
        if(spree > 1)
        {
            #define SPREE_ITEM(counta,countb,center,normal,gentle) \
                case counta: { return normal_or_gentle(center, sprintf(_("%d score spree! "), spree)); }

            switch(spree)
            {
                KILL_SPREE_LIST
                default:
                {
                    if (!autocvar_notification_show_sprees_center_specialonly)
                    {
                        return
                            sprintf(
                                normal_or_gentle(
                                    _("%d frag spree! "),
                                    _("%d score spree! ")
                                ),
                                spree);
                    }
                    else { return ""; } // don't show spree information if it isn't an achievement
                }
            }

            #undef SPREE_ITEM
        }
        else if(spree == -1) // first blood
        {
            return normal_or_gentle(_("First blood! "), _("First score! "));
        }
        else if(spree == -2) // first victim
        {
            return normal_or_gentle(_("First victim! "), _("First casualty! "));
        }
    }
    return "";
}
#endif

string notif_arg_spree_inf(float type, string input, string player, float spree)
{
    switch(type)
    {
        case 1: // attacker kill spree
        {
            // 0 = off, 1 = target only, 2 = attacker only, 3 = target and attacker
            // this conditional (& 2) is true for 2 and 3
            if(autocvar_notification_show_sprees_info & 2)
            {
                #ifdef CSQC
                string spree_newline =
                    ( autocvar_notification_show_sprees_info_newline ?
                        ((substring(input, 0, 1) == "\{3}") ? "\n\{3}" : "\n") : "" );
                #else
                string spree_newline =
                    (autocvar_notification_show_sprees_info_newline ? "\n" : "");
                #endif

                if(spree > 1)
                {
                    #define SPREE_ITEM(counta,countb,center,normal,gentle) \
                        case counta: { return sprintf(CCR(normal_or_gentle(normal, gentle)), player, spree_newline); }

                    switch(spree)
                    {
                        KILL_SPREE_LIST
                        default:
                        {
                            if (!autocvar_notification_show_sprees_info_specialonly)
                            {
                                return
                                    sprintf(
                                        CCR(normal_or_gentle(
                                            _("%s^K1 has %d frags in a row! %s^BG"),
                                            _("%s^K1 made %d scores in a row! %s^BG")
                                        )),
                                        player,
                                        spree,
                                        spree_newline
                                    );
                            }
                            else { return ""; } // don't show spree information if it isn't an achievement
                        }
                    }

                    #undef SPREE_ITEM
                }
                else if(spree == -1) // firstblood
                {
                    return
                        sprintf(
                            CCR(normal_or_gentle(
                                _("%s^K1 drew first blood! %s^BG"),
                                _("%s^K1 got the first score! %s^BG")
                            )),
                            player,
                            spree_newline
                        );
                }
            }
            break;
        }

        case -1: // kill spree ended
        {
            if((spree > 1) && (autocvar_notification_show_sprees_info & 1))
            {
                return
                    sprintf(normal_or_gentle(
                        _(", ending their %d frag spree"),
                        _(", ending their %d score spree")
                        ),
                        spree
                    );
            }
            break;
        }

        case -2: // kill spree lost
        {
            if((spree > 1) && (autocvar_notification_show_sprees_info & 1))
            {
                return
                    sprintf(normal_or_gentle(
                        _(", losing their %d frag spree"),
                        _(", losing their %d score spree")
                        ),
                        spree
                    );
            }
            break;
        }
    }
    return "";
}


// ====================================
//  Initialization/Create Declarations
// ====================================

enum {
    NO_CPID
,   CPID_ASSAULT_ROLE
,   CPID_ROUND
,   CPID_CAMPCHECK
,   CPID_CTF_CAPSHIELD
,   CPID_CTF_LOWPRIO
,   CPID_CTF_PASS
,   CPID_STALEMATE
,   CPID_NADES
,   CPID_IDLING
,   CPID_ITEM
,   CPID_PREVENT_JOIN
,   CPID_KEEPAWAY
,   CPID_KEEPAWAY_WARN
,   CPID_KEYHUNT
,   CPID_KEYHUNT_OTHER
,   CPID_LMS
,   CPID_MISSING_TEAMS
,   CPID_MISSING_PLAYERS
,   CPID_INSTAGIB_FINDAMMO
,   CPID_MOTD
,   CPID_NIX
,   CPID_ONSLAUGHT
,   CPID_ONS_CAPSHIELD
,   CPID_OVERTIME
,   CPID_POWERUP
,   CPID_RACE_FINISHLAP
,   CPID_TEAMCHANGE
,   CPID_TIMEOUT
,   CPID_VEHICLES
,   CPID_VEHICLES_OTHER
// always last
,   NOTIF_CPID_COUNT
};
// notification counts
const float NOTIF_FIRST = 1;
float NOTIF_ANNCE_COUNT;
float NOTIF_INFO_COUNT;
float NOTIF_CENTER_COUNT;
float NOTIF_MULTI_COUNT;
float NOTIF_CHOICE_COUNT;

// notification limits -- INCREASE AS NECESSARY
const float NOTIF_ANNCE_MAX   = 100;
const float NOTIF_INFO_MAX    = 350;
const float NOTIF_CENTER_MAX  = 250;
const float NOTIF_MULTI_MAX   = 200;
const float NOTIF_CHOICE_MAX  = 30;

// notification entities
entity msg_annce_notifs[NOTIF_ANNCE_MAX];
entity msg_info_notifs[NOTIF_INFO_MAX];
entity msg_center_notifs[NOTIF_CENTER_MAX];
entity msg_multi_notifs[NOTIF_MULTI_MAX];
entity msg_choice_notifs[NOTIF_CHOICE_MAX];

// common notification entity values
.float nent_default;
.float nent_enabled;
.float nent_type;
.float nent_id;
.string nent_name;
.int nent_stringcount;
.int nent_floatcount;

// MSG_ANNCE entity values
.float nent_channel;
.string nent_snd;
.float nent_vol;
.float nent_position;

// MSG_INFO and MSG_CENTER entity values
.string nent_args; // used by both
.string nent_hudargs; // used by info
.string nent_icon; // used by info
.float nent_cpid; // used by center
.string nent_durcnt; // used by center
.string nent_string; // used by both

// MSG_MULTI entity values
.entity nent_msgannce;
.entity nent_msginfo;
.entity nent_msgcenter;

// MSG_CHOICE entity values
.float nent_challow_def;
.float nent_challow_var;
.entity nent_optiona;
.entity nent_optionb;

// networked notification entity values
.float nent_broadcast;
.entity nent_client;
.float nent_net_type;
.float nent_net_name;
.string nent_strings[4];
.float nent_floats[4];

// other notification properties
.float msg_choice_choices[NOTIF_CHOICE_MAX]; // set on each player containing MSG_CHOICE choices

// initialization error detection
float notif_error;
float notif_global_error;

#define MSG_ANNCE_NOTIF(default,name,channel,sound,volume,position) \
    NOTIF_ADD_AUTOCVAR(name, default) \
    float name; \
    void RegisterNotification_##name() \
    { \
        SET_FIELD_COUNT(name, NOTIF_FIRST, NOTIF_ANNCE_COUNT) \
        CHECK_MAX_COUNT(name, NOTIF_ANNCE_MAX, NOTIF_ANNCE_COUNT, "MSG_ANNCE") \
        Create_Notification_Entity( \
            /* COMMON ======================== */ \
            default,            /* var_default */ \
            ACVNN(name),        /* var_cvar    */ \
            MSG_ANNCE,          /* typeId      */ \
            name,               /* nameid      */ \
            strtoupper(#name),  /* namestring  */ \
            NO_MSG,             /* strnum      */ \
            NO_MSG,             /* flnum       */ \
            /* ANNCE ============= */ \
            channel,   /* channel  */ \
            sound,     /* snd      */ \
            volume,    /* vol      */ \
            position,  /* position */ \
            /* INFO & CENTER == */ \
            "",      /* args    */ \
            "",      /* hudargs */ \
            "",      /* icon    */ \
            NO_MSG,  /* cpid    */ \
            "",      /* durcnt  */ \
            "",      /* normal  */ \
            "",      /* gentle  */ \
            /* MULTI ============= */ \
            NO_MSG,  /* anncename  */ \
            NO_MSG,  /* infoname   */ \
            NO_MSG,  /* centername */ \
            /* MSG_CHOICE ========== */ \
            NO_MSG,   /* challow_def */ \
            NO_MSG,   /* challow_var */ \
            NO_MSG,   /* chtype      */ \
            NO_MSG,   /* optiona     */ \
            NO_MSG);  /* optionb     */ \
    } \
    ACCUMULATE_FUNCTION(RegisterNotifications, RegisterNotification_##name)

#define MSG_INFO_NOTIF(default,name,strnum,flnum,args,hudargs,icon,normal,gentle) \
    NOTIF_ADD_AUTOCVAR(name, default) \
    int name; \
    void RegisterNotification_##name() \
    { \
        SET_FIELD_COUNT(name, NOTIF_FIRST, NOTIF_INFO_COUNT) \
        CHECK_MAX_COUNT(name, NOTIF_INFO_MAX, NOTIF_INFO_COUNT, "MSG_INFO") \
        Create_Notification_Entity( \
            /* COMMON ======================== */ \
            default,            /* var_default */ \
            ACVNN(name),        /* var_cvar    */ \
            MSG_INFO,           /* typeId      */ \
            name,               /* nameid      */ \
            strtoupper(#name),  /* namestring  */ \
            strnum,             /* strnum      */ \
            flnum,              /* flnum       */ \
            /* ANNCE =========== */ \
            NO_MSG,  /* channel  */ \
            "",      /* snd      */ \
            NO_MSG,  /* vol      */ \
            NO_MSG,  /* position */ \
            /* INFO & CENTER === */ \
            args,     /* args    */ \
            hudargs,  /* hudargs */ \
            icon,     /* icon    */ \
            NO_MSG,   /* cpid    */ \
            "",       /* durcnt  */ \
            normal,   /* normal  */ \
            gentle,   /* gentle  */ \
            /* MULTI ============= */ \
            NO_MSG,  /* anncename  */ \
            NO_MSG,  /* infoname   */ \
            NO_MSG,  /* centername */ \
            /* CHOICE ============== */ \
            NO_MSG,   /* challow_def */ \
            NO_MSG,   /* challow_var */ \
            NO_MSG,   /* chtype      */ \
            NO_MSG,   /* optiona     */ \
            NO_MSG);  /* optionb     */ \
    } \
    ACCUMULATE_FUNCTION(RegisterNotifications, RegisterNotification_##name)

.string nent_iconargs;
#define MULTIICON_INFO(default,name,strnum,flnum,args,hudargs,iconargs,icon,normal,gentle) \
    NOTIF_ADD_AUTOCVAR(name, default) \
    int name; \
    void RegisterNotification_##name() \
    { \
        SET_FIELD_COUNT(name, NOTIF_FIRST, NOTIF_INFO_COUNT) \
        CHECK_MAX_COUNT(name, NOTIF_INFO_MAX, NOTIF_INFO_COUNT, "MSG_INFO") \
        Create_Notification_Entity( \
            /* COMMON ======================== */ \
            default,            /* var_default */ \
            ACVNN(name),        /* var_cvar    */ \
            MSG_INFO,           /* typeid      */ \
            name,               /* nameid      */ \
            strtoupper(#name),  /* namestring  */ \
            strnum,             /* strnum      */ \
            flnum,              /* flnum       */ \
            /* ANNCE =========== */ \
            NO_MSG,  /* channel  */ \
            "",      /* snd      */ \
            NO_MSG,  /* vol      */ \
            NO_MSG,  /* position */ \
            /* INFO & CENTER === */ \
            args,     /* args    */ \
            hudargs,  /* hudargs */ \
            icon,     /* icon    */ \
            NO_MSG,   /* cpid    */ \
            "",       /* durcnt  */ \
            normal,   /* normal  */ \
            gentle,   /* gentle  */ \
            /* MULTI ============= */ \
            NO_MSG,  /* anncename  */ \
            NO_MSG,  /* infoname   */ \
            NO_MSG,  /* centername */ \
            /* CHOICE ============== */ \
            NO_MSG,   /* challow_def */ \
            NO_MSG,   /* challow_var */ \
            NO_MSG,   /* chtype      */ \
            NO_MSG,   /* optiona     */ \
            NO_MSG);  /* optionb     */ \
        msg_info_notifs[name - 1].nent_iconargs = iconargs; \
    } \
    ACCUMULATE_FUNCTION(RegisterNotifications, RegisterNotification_##name)

#define MSG_CENTER_NOTIF(default,name,strnum,flnum,args,cpid,durcnt,normal,gentle) \
    NOTIF_ADD_AUTOCVAR(name, default) \
    float name; \
    void RegisterNotification_##name() \
    { \
        SET_FIELD_COUNT(name, NOTIF_FIRST, NOTIF_CENTER_COUNT) \
        CHECK_MAX_COUNT(name, NOTIF_CENTER_MAX, NOTIF_CENTER_COUNT, "MSG_CENTER") \
        Create_Notification_Entity( \
            /* COMMON ======================== */ \
            default,            /* var_default */ \
            ACVNN(name),        /* var_cvar    */ \
            MSG_CENTER,         /* typeId      */ \
            name,               /* nameid      */ \
            strtoupper(#name),  /* namestring  */ \
            strnum,             /* strnum      */ \
            flnum,              /* flnum       */ \
            /* ANNCE =========== */ \
            NO_MSG,  /* channel  */ \
            "",      /* snd      */ \
            NO_MSG,  /* vol      */ \
            NO_MSG,  /* position */ \
            /* INFO & CENTER == */ \
            args,    /* args    */ \
            "",      /* hudargs */ \
            "",      /* icon    */ \
            cpid,    /* cpid    */ \
            durcnt,  /* durcnt  */ \
            normal,  /* normal  */ \
            gentle,  /* gentle  */ \
            /* MULTI ============= */ \
            NO_MSG,  /* anncename  */ \
            NO_MSG,  /* infoname   */ \
            NO_MSG,  /* centername */ \
            /* CHOICE ============== */ \
            NO_MSG,   /* challow_def */ \
            NO_MSG,   /* challow_var */ \
            NO_MSG,   /* chtype      */ \
            NO_MSG,   /* optiona     */ \
            NO_MSG);  /* optionb     */ \
    } \
    ACCUMULATE_FUNCTION(RegisterNotifications, RegisterNotification_##name)

#define MSG_MULTI_NOTIF(default,name,anncename,infoname,centername) \
    NOTIF_ADD_AUTOCVAR(name, default) \
    int name; \
    void RegisterNotification_##name() \
    { \
        SET_FIELD_COUNT(name, NOTIF_FIRST, NOTIF_MULTI_COUNT) \
        CHECK_MAX_COUNT(name, NOTIF_MULTI_MAX, NOTIF_MULTI_COUNT, "MSG_MULTI") \
        Create_Notification_Entity( \
            /* COMMON ======================== */ \
            default,            /* var_default */ \
            ACVNN(name),        /* var_cvar    */ \
            MSG_MULTI,          /* typeId      */ \
            name,               /* nameid      */ \
            strtoupper(#name),  /* namestring  */ \
            NO_MSG,             /* strnum      */ \
            NO_MSG,             /* flnum       */ \
            /* ANNCE =========== */ \
            NO_MSG,  /* channel  */ \
            "",      /* snd      */ \
            NO_MSG,  /* vol      */ \
            NO_MSG,  /* position */ \
            /* INFO & CENTER == */ \
            "",      /* args    */ \
            "",      /* hudargs */ \
            "",      /* icon    */ \
            NO_MSG,  /* cpid    */ \
            "",      /* durcnt  */ \
            "",      /* normal  */ \
            "",      /* gentle  */ \
            /* MULTI ================= */ \
            anncename,   /* anncename  */ \
            infoname,    /* infoname   */ \
            centername,  /* centername */ \
            /* CHOICE ============== */ \
            NO_MSG,   /* challow_def */ \
            NO_MSG,   /* challow_var */ \
            NO_MSG,   /* chtype      */ \
            NO_MSG,   /* optiona     */ \
            NO_MSG);  /* optionb     */ \
    } \
    ACCUMULATE_FUNCTION(RegisterNotifications, RegisterNotification_##name)

#define ACVNN(name) autocvar_notification_##name

#define MSG_CHOICE_NOTIF(default,challow,name,chtype,optiona,optionb) \
    NOTIF_ADD_AUTOCVAR(name, default) \
    NOTIF_ADD_AUTOCVAR(name##_ALLOWED, challow) \
    float name; \
    void RegisterNotification_##name() \
    { \
        SET_FIELD_COUNT(name, NOTIF_FIRST, NOTIF_CHOICE_COUNT) \
        CHECK_MAX_COUNT(name, NOTIF_CHOICE_MAX, NOTIF_CHOICE_COUNT, "MSG_CHOICE") \
        Create_Notification_Entity( \
            /* COMMON ======================== */ \
            default,            /* var_default */ \
            ACVNN(name),        /* var_cvar    */ \
            MSG_CHOICE,         /* typeId      */ \
            name,               /* nameid      */ \
            strtoupper(#name),  /* namestring  */ \
            NO_MSG,             /* strnum      */ \
            NO_MSG,             /* flnum       */ \
            /* ANNCE =========== */ \
            NO_MSG,  /* channel  */ \
            "",      /* snd      */ \
            NO_MSG,  /* vol      */ \
            NO_MSG,  /* position */ \
            /* INFO & CENTER == */ \
            "",      /* args    */ \
            "",      /* hudargs */ \
            "",      /* icon    */ \
            NO_MSG,  /* cpid    */ \
            "",      /* durcnt  */ \
            "",      /* normal  */ \
            "",      /* gentle  */ \
            /* MULTI ============= */ \
            NO_MSG,  /* anncename  */ \
            NO_MSG,  /* infoname   */ \
            NO_MSG,  /* centername */ \
            /* CHOICE ============================================= */ \
            challow,                                 /* challow_def */ \
            autocvar_notification_##name##_ALLOWED,  /* challow_var */ \
            chtype,                                  /* chtype      */ \
            optiona,                                 /* optiona     */ \
            optionb);                                /* optionb     */ \
    } \
    ACCUMULATE_FUNCTION(RegisterNotifications, RegisterNotification_##name)

void RegisterNotifications_First()
{
    notif_global_error = false;

    #ifdef SVQC
    #define dedi (server_is_dedicated ? "a dedicated " : "")
    #else
    #define dedi ""
    #endif

    LOG_INFOF("Beginning notification initialization on %s%s program...\n", dedi, PROGNAME);
    #undef dedi

    // maybe do another implementation of this with checksums? for now, we don't need versioning
    /*if(autocvar_notification_version != NOTIF_VERSION)
    {
        #ifdef CSQC
        if(autocvar_notification_version_mismatch_client_error)
        #else
        if(autocvar_notification_version_mismatch_server_error)
        #endif
            notif_global_error = true;

        printf("^1NOTIFICATION VERSION MISMATCH: ^7program = %s, config = %d, code = %d.\n",
            PROGNAME, autocvar_notification_version, NOTIF_VERSION);
    }*/
}

void RegisterNotifications_Done()
{
    if(notif_global_error)
    {
        // shit happened... stop the loading of the program now if this is unacceptable
        if(autocvar_notification_errors_are_fatal)
            error("Notification initialization failed! Read above and fix the errors!\n");
        else
            LOG_INFO("Notification initialization failed! Read above and fix the errors!\n");
    }
    else { LOG_INFO("Notification initialization successful!\n"); }
}

// NOW we actually activate the declarations
ACCUMULATE_FUNCTION(RegisterNotifications, RegisterNotifications_First)
#include "notifications.inc"
ACCUMULATE_FUNCTION(RegisterNotifications, RegisterNotifications_Done)

#endif
