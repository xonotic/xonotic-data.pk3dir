#ifndef DEBUG_H
#define DEBUG_H

#ifndef MENUQC
.bool debug;
.int sv_entnum;
REGISTER_NET_TEMP(net_debug)
#endif

#ifdef CSQC
	NET_HANDLE(net_debug, bool isNew)
	{
		Net_Accept(net_debug);
		this.sv_entnum = ReadShort();
		if (ReadByte()) make_pure(this);
		this.origin_x = ReadCoord();
		this.origin_y = ReadCoord();
		this.origin_z = ReadCoord();
		setorigin(this, this.origin);
		this.debug = true;  // identify server entities by this
		this.classname = strzone(ReadString());
		this.sourceLoc = strzone(ReadString());
		return true;
	}
#endif

#ifdef SVQC
	bool debug_send(entity this, entity to, int sf)
	{
		int channel = MSG_ONE;
		msg_entity = to;
		WriteHeader(channel, net_debug);
		WriteShort(channel, etof(this));
		WriteByte(channel, is_pure(this));
		WriteCoord(channel, this.origin.x);
		WriteCoord(channel, this.origin.y);
		WriteCoord(channel, this.origin.z);
		WriteString(channel, this.classname);
		WriteString(channel, this.sourceLoc);
		return true;
	}
#endif

#ifndef MENUQC
bool autocvar_debugdraw;
#endif

#ifdef CSQC
	string autocvar_debugdraw_filter, autocvar_debugdraw_filterout;
	.int debugdraw_last;
	vector project_3d_to_2d(vector vec);
	void Debug_Draw()
	{
		if (!autocvar_debugdraw) return;
		static int debugdraw_frame;
		++debugdraw_frame;
		const int sz = 8;
		FOREACH_ENTITY(true, LAMBDA(
			if (it.debugdraw_last == debugdraw_frame) continue;
			int ofs = 0;
			for (entity e = findradius(it.origin, 100); e; e = e.chain)
			{
				if (e.debugdraw_last == debugdraw_frame) continue;
				e.debugdraw_last = debugdraw_frame;
				vector rgb = (e.debug) ? '0 0 1' : '1 0 0';
				if (autocvar_debugdraw_filterout != "" && strhasword(autocvar_debugdraw_filterout, e.classname)) continue;
				if (autocvar_debugdraw_filter != "" && !strhasword(autocvar_debugdraw_filter, e.classname)) continue;
				if (autocvar_debugdraw == 3)
				{
					if (!e.entnum) continue;
				}
				if (autocvar_debugdraw == 4)
				{
					if (e.origin) continue;
				}
				else if (autocvar_debugdraw > 4)
				{
					bool flag = true;
					do {
//						if (e.modelindex) break;
//						if (e.absmin) break;
//						if (e.absmax) break;
//						if (e.entnum) break;
//						if (e.drawmask) break;
//						if (e.predraw) break;
//						if (e.movetype) break;
						if (e.solid) break;
//						if (e.origin) break;
//						if (e.oldorigin) break;
//						if (e.velocity) break;
//						if (e.angles) break;
//						if (e.avelocity) break;
//						if (e.classname) break;
//						if (e.model) break;
//						if (e.frame) break;
//						if (e.skin) break;
//						if (e.effects) break;
//						if (e.mins) break;
//						if (e.maxs) break;
//						if (e.size) break;
//						if (e.touch) break;
//						if (e.use) break;
//						if (e.think) break;
//						if (e.blocked) break;
//						if (e.nextthink) break;
//						if (e.chain) break;
//						if (e.netname) break;
//						if (e.enemy) break;
//						if (e.flags) break;
//						if (e.colormap) break;
//						if (e.owner) break;
						flag = false;
					} while (0);
					if (!flag) continue;
				}
				else if (is_pure(e))
				{
					if (autocvar_debugdraw < 2) continue;
					rgb.y = 1;
				}
				vector pos = project_3d_to_2d(e.origin);
				if (pos.z < 0) continue;
				pos.z = 0;
				pos.y += ofs * sz;
				drawcolorcodedstring2(pos,
					sprintf("%d: '%s'@%s", (e.debug ? e.sv_entnum : etof(e)),
					e.classname, e.sourceLoc),
					sz * '1 1 0', rgb, 0.5, DRAWFLAG_NORMAL);
				++ofs;
			}
		));
	}
#endif

#ifdef SVQC
	COMMON_COMMAND(debugdraw_sv, "Dump all server entities")
	{
		switch (request)
		{
			case CMD_REQUEST_COMMAND:
			{
				if (!autocvar_debugdraw) return;
				int n = 1000;
				int rem = n;
				for (entity e = NULL; (e = findfloat(e, debug, 0)) && rem > 0; )
				{
					if (autocvar_debugdraw < 2 && is_pure(e)) continue;
					debug_send(e, nextent(NULL), 0);
					e.debug = true;
					--rem;
				}
				LOG_INFOF("%d server entities sent\n", n - rem);
				return;
			}

			default:
			case CMD_REQUEST_USAGE:
			{
				LOG_INFO(strcat("\nUsage:^3 ", GetProgramCommandPrefix(), " debugdraw_sv"));
				return;
			}
		}
	}
#endif

GENERIC_COMMAND(bufstr_get, "Examine a string buffer object")
{
	switch (request)
	{
		case CMD_REQUEST_COMMAND:
		{
		    int bufhandle = stof(argv(1));
		    int string_index = stof(argv(2));
			string s = bufstr_get(bufhandle, string_index);
			LOG_INFOF("%s\n", s);
			return;
		}

		default:
		case CMD_REQUEST_USAGE:
		{
			LOG_INFO(strcat("\nUsage:^3 ", GetProgramCommandPrefix(), " bufstr_get bufhandle string_index"));
			return;
		}
	}
}

GENERIC_COMMAND(version, "Print the current version")
{
	switch (request)
	{
		case CMD_REQUEST_COMMAND:
		{
			LOG_INFO(WATERMARK "\n");
			return;
		}
		default:
		case CMD_REQUEST_USAGE:
		{
			LOG_INFO(strcat("\nUsage:^3 ", GetProgramCommandPrefix(), " version"));
			return;
		}
	}
}

#endif
