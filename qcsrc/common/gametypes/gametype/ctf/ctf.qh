#pragma once

#include <common/mapinfo.qh>
#ifdef CSQC
	#include "cl_ctf.qh"
#endif

CLASS(CaptureTheFlag, Gametype)
	INIT(CaptureTheFlag)
	{
		this.gametype_init(this, _("Capture the Flag"),"ctf","g_ctf",GAMETYPE_FLAG_TEAMPLAY | GAMETYPE_FLAG_USEPOINTS | GAMETYPE_FLAG_PRIORITY,"","timelimit=20 caplimit=10 leadlimit=6",_("Find and bring the enemy flag to your base to capture it, defend your base from the other team"));
	}
	METHOD(CaptureTheFlag, m_generate_mapinfo, void(Gametype this, string v))
	{
		if(v == "item_flag_team2" || v == "team_CTF_blueflag")
			MapInfo_Map_supportedGametypes |= this.gametype_flags;
	}
	METHOD(CaptureTheFlag, m_isTwoBaseMode, bool())
	{
		return true;
	}
	METHOD(CaptureTheFlag, m_setTeams, void(string sa))
	{
		cvar_set("fraglimit", sa);
	}
	METHOD(CaptureTheFlag, m_configuremenu, void(Gametype this, entity menu, void(entity me, string pLabel, float pMin, float pMax, float pStep, string pCvar, string tCvar, string pTooltip) returns))
	{
		TC(Gametype, this);
		returns(menu, _("Capture limit:"),   1,   20,  1, "capturelimit_override",     string_null,                    _("The amount of captures needed before the match will end"));
	}
#ifdef CSQC
	ATTRIB(CaptureTheFlag, m_modicons, void(vector myPos, vector mySize, bool should_draw), HUD_Mod_CTF);
#endif
	ATTRIB(CaptureTheFlag, m_legacydefaults, string, "300 20 10 0");
ENDCLASS(CaptureTheFlag)
REGISTER_GAMETYPE(CTF, NEW(CaptureTheFlag));
#define g_ctf IS_GAMETYPE(CTF)

#ifdef GAMEQC
REGISTER_NET_LINKED(ENT_CLIENT_CTF_FLAGSTATUSES)
const int SF_CTF_FLAGS         = BIT(0);
const int SF_CTF_SPEC          = BIT(1);
const int SF_CTF_SPEC_CHANGED  = BIT(2);
const int SF_CTF_ONEFLAG       = BIT(3);
const int SF_CTF_STALEMATE     = BIT(4);
const int SF_CTF_SHIELDED      = BIT(5);
#endif
