#ifndef TURRET_EWHEEL_H
#define TURRET_EWHEEL_H

//#define EWHEEL_FANCYPATH

#include "ewheel_weapon.qh"

CLASS(EWheel, Turret)
/* spawnflags */ ATTRIB(EWheel, spawnflags, int, TUR_FLAG_PLAYER | TUR_FLAG_MOVE | TUR_FLAG_ROAM);
/* mins       */ ATTRIB(EWheel, mins, vector, '-32 -32 0');
/* maxs       */ ATTRIB(EWheel, maxs, vector, '32 32 48');
/* modelname  */ ATTRIB(EWheel, mdl, string, "ewheel-base2.md3");
/* model      */ ATTRIB_STRZONE(EWheel, model, string, strcat("models/turrets/", this.mdl));
/* head_model */ ATTRIB_STRZONE(EWheel, head_model, string, strcat("models/turrets/", "ewheel-gun1.md3"));
/* netname    */ ATTRIB(EWheel, netname, string, "ewheel");
/* fullname   */ ATTRIB(EWheel, turret_name, string, _("eWheel Turret"));
    ATTRIB(EWheel, m_weapon, Weapon, WEP_EWHEEL);
ENDCLASS(EWheel)
REGISTER_TURRET(EWHEEL, NEW(EWheel));

#endif

#ifdef IMPLEMENTATION

#ifdef SVQC

float autocvar_g_turrets_unit_ewheel_speed_fast;
float autocvar_g_turrets_unit_ewheel_speed_slow;
float autocvar_g_turrets_unit_ewheel_speed_slower;
float autocvar_g_turrets_unit_ewheel_speed_stop;
float autocvar_g_turrets_unit_ewheel_turnrate;

const float ewheel_anim_stop = 0;
const float ewheel_anim_fwd_slow = 1;
const float ewheel_anim_fwd_fast = 2;
const float ewheel_anim_bck_slow = 3;
const float ewheel_anim_bck_fast = 4;

void ewheel_move_path(entity this)
{
#ifdef EWHEEL_FANCYPATH
    // Are we close enougth to a path node to switch to the next?
    if(vdist(this.origin - this.pathcurrent.origin, <, 64))
        if (this.pathcurrent.path_next == NULL)
        {
            // Path endpoint reached
            pathlib_deletepath(this.pathcurrent.owner);
            this.pathcurrent = NULL;

            if (this.pathgoal)
            {
                if (this.pathgoal.use)
                    this.pathgoal.use(this.pathgoal, NULL, NULL);

                if (this.pathgoal.enemy)
                {
                    this.pathcurrent = pathlib_astar(this, this.pathgoal.origin,this.pathgoal.enemy.origin);
                    this.pathgoal = this.pathgoal.enemy;
                }
            }
            else
                this.pathgoal = NULL;
        }
        else
            this.pathcurrent = this.pathcurrent.path_next;

#else
    if(vdist(this.origin - this.pathcurrent.origin, <, 64))
        this.pathcurrent = this.pathcurrent.enemy;
#endif

    if (this.pathcurrent)
    {

        this.moveto = this.pathcurrent.origin;
        this.steerto = steerlib_attract2(this, this.moveto, 0.5, 500, 0.95);

        movelib_move_simple(this, v_forward, (autocvar_g_turrets_unit_ewheel_speed_fast), 0.4);
    }
}

void ewheel_move_enemy(entity this)
{
    float newframe;

    this.steerto = steerlib_arrive(this, this.enemy.origin,this.target_range_optimal);

    this.moveto  = this.origin + this.steerto * 128;

    if (this.tur_dist_enemy > this.target_range_optimal)
    {
        if ( this.tur_head.spawnshieldtime < 1 )
        {
            newframe = ewheel_anim_fwd_fast;
            movelib_move_simple(this, v_forward, (autocvar_g_turrets_unit_ewheel_speed_fast), 0.4);
        }
        else if (this.tur_head.spawnshieldtime < 2)
        {

            newframe = ewheel_anim_fwd_slow;
            movelib_move_simple(this, v_forward, (autocvar_g_turrets_unit_ewheel_speed_slow), 0.4);
       }
        else
        {
            newframe = ewheel_anim_fwd_slow;
            movelib_move_simple(this, v_forward, (autocvar_g_turrets_unit_ewheel_speed_slower), 0.4);
        }
    }
    else if (this.tur_dist_enemy < this.target_range_optimal * 0.5)
    {
        newframe = ewheel_anim_bck_slow;
        movelib_move_simple(this, v_forward * -1, (autocvar_g_turrets_unit_ewheel_speed_slow), 0.4);
    }
    else
    {
        newframe = ewheel_anim_stop;
        movelib_brake_simple(this, (autocvar_g_turrets_unit_ewheel_speed_stop));
    }

    turrets_setframe(this, newframe, false);
}

void ewheel_move_idle(entity this)
{
    if(this.frame != 0)
    {
        this.SendFlags |= TNSF_ANIM;
        this.anim_start_time = time;
    }

    this.frame = 0;
    if(this.velocity)
        movelib_brake_simple(this, (autocvar_g_turrets_unit_ewheel_speed_stop));
}

spawnfunc(turret_ewheel) { if(!turret_initialize(this, TUR_EWHEEL)) remove(this); }

METHOD(EWheel, tr_think, void(EWheel thistur, entity it))
{
    float vz;
    vector wish_angle, real_angle;

    vz = it.velocity_z;

    it.angles_x = anglemods(it.angles_x);
    it.angles_y = anglemods(it.angles_y);

    fixedmakevectors(it.angles);

    wish_angle = normalize(it.steerto);
    wish_angle = vectoangles(wish_angle);
    real_angle = wish_angle - it.angles;
    real_angle = shortangle_vxy(real_angle, it.tur_head.angles);

    it.tur_head.spawnshieldtime = fabs(real_angle_y);
    real_angle_y  = bound(-it.tur_head.aim_speed, real_angle_y, it.tur_head.aim_speed);
    it.angles_y = (it.angles_y + real_angle_y);

    if(it.enemy)
        ewheel_move_enemy(it);
    else if(it.pathcurrent)
        ewheel_move_path(it);
    else
        ewheel_move_idle(it);

    it.velocity_z = vz;

    if(it.velocity)
        it.SendFlags |= TNSF_MOVE;
}

METHOD(EWheel, tr_death, void(EWheel this, entity it))
{
    it.velocity = '0 0 0';

#ifdef EWHEEL_FANCYPATH
    if (it.pathcurrent)
        pathlib_deletepath(it.pathcurrent.owner);
#endif
    it.pathcurrent = NULL;
}

METHOD(EWheel, tr_setup, void(EWheel this, entity it))
{
    entity e;

    if(it.movetype == MOVETYPE_WALK)
    {
        it.velocity = '0 0 0';
        it.enemy = NULL;

        setorigin(it, it.pos1);

        if (it.target != "")
        {
            e = find(NULL, targetname, it.target);
            if (!e)
            {
                LOG_TRACE("Initital waypoint for ewheel does NOT exsist, fix your map!\n");
                it.target = "";
            }

            if (e.classname != "turret_checkpoint")
                LOG_TRACE("Warning: not a turrret path\n");
            else
            {

#ifdef EWHEEL_FANCYPATH
                it.pathcurrent = WALKER_PATH(it, it.origin, e.origin);
                it.pathgoal = e;
#else
                it.pathcurrent  = e;
#endif
            }
        }
    }

    it.iscreature				= true;
    it.teleportable			= TELEPORT_NORMAL;
    it.damagedbycontents		= true;
    it.movetype				= MOVETYPE_WALK;
    it.solid					= SOLID_SLIDEBOX;
    it.takedamage				= DAMAGE_AIM;
    it.idle_aim				= '0 0 0';
    it.pos1					= it.origin;
    it.target_select_flags	= TFL_TARGETSELECT_PLAYERS | TFL_TARGETSELECT_RANGELIMITS | TFL_TARGETSELECT_TEAMCHECK | TFL_TARGETSELECT_LOS;
    it.target_validate_flags	= TFL_TARGETSELECT_PLAYERS | TFL_TARGETSELECT_RANGELIMITS | TFL_TARGETSELECT_TEAMCHECK | TFL_TARGETSELECT_LOS;
    it.frame					= it.tur_head.frame = 1;
    it.ammo_flags				= TFL_AMMO_ENERGY | TFL_AMMO_RECHARGE | TFL_AMMO_RECIEVE;

    // Convert from dgr / sec to dgr / tic
    it.tur_head.aim_speed = (autocvar_g_turrets_unit_ewheel_turnrate);
    it.tur_head.aim_speed = it.tur_head.aim_speed / (1 / it.ticrate);
}

#endif // SVQC
#ifdef CSQC

void ewheel_draw(entity this)
{
    float dt;

    dt = time - this.move_time;
    this.move_time = time;
    if(dt <= 0)
        return;

    fixedmakevectors(this.angles);
    setorigin(this, this.origin + this.velocity * dt);
    this.tur_head.angles += dt * this.tur_head.move_avelocity;
    this.angles_y = this.move_angles_y;

    if (this.health < 127)
    if(random() < 0.05)
        te_spark(this.origin + '0 0 40', randomvec() * 256 + '0 0 256', 16);
}

        METHOD(EWheel, tr_setup, void(EWheel this, entity it))
        {
            it.gravity		= 1;
            it.movetype		= MOVETYPE_BOUNCE;
            it.move_movetype	= MOVETYPE_BOUNCE;
            it.move_origin	= it.origin;
            it.move_time		= time;
            it.draw			= ewheel_draw;
        }

#endif // CSQC
#endif
