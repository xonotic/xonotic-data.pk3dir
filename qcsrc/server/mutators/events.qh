#ifndef SERVER_MUTATORS_EVENTS_H
#define SERVER_MUTATORS_EVENTS_H

#include "../../common/mutators/base.qh"

// register all possible hooks here

/** called when a player becomes observer, after shared setup */
#define EV_MakePlayerObserver(i, o) \
    /**/
MUTATOR_HOOKABLE(MakePlayerObserver, EV_MakePlayerObserver)

/** */
#define EV_PutClientInServer(i, o) \
    /** client wanting to spawn */ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(PutClientInServer, EV_PutClientInServer);

/** called when a player spawns as player, after shared setup, before his weapon is chosen (so items may be changed in here) */
#define EV_PlayerSpawn(i, o) \
    /** spot that was used, or world */ i(entity, spawn_spot) \
    /**/
entity spawn_spot;
MUTATOR_HOOKABLE(PlayerSpawn, EV_PlayerSpawn);

/** called in reset_map */
#define EV_reset_map_global(i, o) \
    /**/
MUTATOR_HOOKABLE(reset_map_global, EV_reset_map_global);

/** called in reset_map */
#define EV_reset_map_players(i, o) \
    /**/
MUTATOR_HOOKABLE(reset_map_players, EV_reset_map_players);

/** returns 1 if clearing player score shall not be allowed */
#define EV_ForbidPlayerScore_Clear(i, o) \
    /**/
MUTATOR_HOOKABLE(ForbidPlayerScore_Clear, EV_ForbidPlayerScore_Clear);

/** called when a player disconnects */
#define EV_ClientDisconnect(i, o) \
    /**/
MUTATOR_HOOKABLE(ClientDisconnect, EV_ClientDisconnect);

/** called when a player dies to e.g. remove stuff he was carrying. */
#define EV_PlayerDies(i, o) \
    /**/ i(entity, frag_inflictor) \
    /**/ i(entity, frag_attacker) \
    /** same as self */ i(entity, frag_target) \
    /**/ i(int, frag_deathtype) \
    /**/
entity frag_inflictor;
entity frag_attacker;
entity frag_target;
int frag_deathtype;
MUTATOR_HOOKABLE(PlayerDies, EV_PlayerDies);

/** called when a player dies to e.g. remove stuff he was carrying */
#define EV_PlayHitsound(i, o) \
    /**/ i(entity, frag_victim) \
    /**/
entity frag_victim;
MUTATOR_HOOKABLE(PlayHitsound, EV_PlayHitsound);

/** called when a weapon sound is about to be played, allows custom paths etc. */
#define EV_WeaponSound(i, o) \
    /**/ i(string, weapon_sound) \
    /**/ i(string, weapon_sound_output) \
    /**/ o(string, weapon_sound_output) \
    /**/
string weapon_sound;
string weapon_sound_output;
MUTATOR_HOOKABLE(WeaponSound, EV_WeaponSound);

/** called when an item model is about to be set, allows custom paths etc. */
#define EV_ItemModel(i, o) \
    /**/ i(string, item_model) \
    /**/ i(string, item_model_output) \
    /**/ o(string, item_model_output) \
    /**/
string item_model;
string item_model_output;
MUTATOR_HOOKABLE(ItemModel, EV_ItemModel);

/** called when someone was fragged by "self", and is expected to change frag_score to adjust scoring for the kill */
#define EV_GiveFragsForKill(i, o) \
    /**/ i(entity, __self) \
    /** same as self */ i(entity, frag_attacker) \
    /**/ i(entity, frag_target) \
    /**/ i(float, frag_score) \
    /**/ o(float, frag_score) \
    /**/
float frag_score;
MUTATOR_HOOKABLE(GiveFragsForKill, EV_GiveFragsForKill);

/** called when the match ends */
MUTATOR_HOOKABLE(MatchEnd, EV_NO_ARGS);

/** should adjust ret_float to contain the team count */
#define EV_GetTeamCount(i, o) \
    /**/ i(float, ret_float) \
    /**/ o(float, ret_float) \
    /**/ i(string, ret_string) \
    /**/ o(string, ret_string) \
    /**/
float ret_float;
MUTATOR_HOOKABLE(GetTeamCount, EV_GetTeamCount);

/** copies variables for spectating "other" to "self" */
#define EV_SpectateCopy(i, o) \
    /**/ i(entity, other) \
    /**/ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(SpectateCopy, EV_SpectateCopy);

/** called when formatting a chat message to replace fancy functions */
#define EV_FormatMessage(i, o) \
    /**/ i(string, format_escape) \
    /**/ i(string, format_replacement) \
    /**/ o(string, format_replacement) \
    /**/ i(string, format_message) \
    /**/
string format_escape;
string format_replacement;
string format_message;
MUTATOR_HOOKABLE(FormatMessage, EV_FormatMessage);

/** returns true if throwing the current weapon shall not be allowed */
MUTATOR_HOOKABLE(ForbidThrowCurrentWeapon, EV_NO_ARGS);

/** returns true if dropping the current weapon shall not be allowed at any time including death */
MUTATOR_HOOKABLE(ForbidDropCurrentWeapon, EV_NO_ARGS);

/**  */
MUTATOR_HOOKABLE(SetDefaultAlpha, EV_NO_ARGS);

/** allows changing attack rate */
#define EV_WeaponRateFactor(i, o) \
    /**/ i(float, weapon_rate) \
    /**/ o(float, weapon_rate) \
    /**/
float weapon_rate;
MUTATOR_HOOKABLE(WeaponRateFactor, EV_WeaponRateFactor);

/** allows changing weapon speed (projectiles mostly) */
#define EV_WeaponSpeedFactor(i, o) \
    /**/ i(float, ret_float) \
    /**/ o(float, ret_float) \
    /**/
MUTATOR_HOOKABLE(WeaponSpeedFactor, EV_WeaponSpeedFactor);

/** adjusts {warmup_}start_{items,weapons,ammo_{cells,plasma,rockets,nails,shells,fuel}} */
MUTATOR_HOOKABLE(SetStartItems, EV_NO_ARGS);

/** called every frame. customizes the waypoint for spectators */
#define EV_CustomizeWaypoint(i, o) \
    /** waypoint */ i(entity, __self) \
    /** player; other.enemy = spectator */ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(CustomizeWaypoint, EV_CustomizeWaypoint);

/**
 * checks if the current item may be spawned (self.items and self.weapons may be read and written to, as well as the ammo_ fields)
 * return error to request removal
 */
#define EV_FilterItem(i, o) \
    /** the current item */ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(FilterItem, EV_FilterItem);

/** return error to request removal */
#define EV_TurretSpawn(i, o) \
    /** turret */ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(TurretSpawn, EV_TurretSpawn);

/** return error to not attack */
#define EV_TurretFire(i, o) \
    /** turret */ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(TurretFire, EV_TurretFire);

/** return error to not attack */
#define EV_Turret_CheckFire(i, o) \
    /**/ i(bool, ret_bool) \
    /**/ o(bool, ret_bool) \
    /**/
bool ret_bool;
MUTATOR_HOOKABLE(Turret_CheckFire, EV_Turret_CheckFire);

/** return error to prevent entity spawn, or modify the entity */
MUTATOR_HOOKABLE(OnEntityPreSpawn, EV_NO_ARGS);

/** runs in the event loop for players; is called for ALL player entities, also bots, also the dead, or spectators */
MUTATOR_HOOKABLE(PlayerPreThink, EV_NO_ARGS);

/** TODO change this into a general PlayerPostThink hook? */
MUTATOR_HOOKABLE(GetPressedKeys, EV_NO_ARGS);

/** is meant to call GetCvars_handle*(get_cvars_s, get_cvars_f, cvarfield, "cvarname") for cvars this mutator needs from the client */
#define EV_GetCvars(i, o) \
    /**/ i(float, get_cvars_f) \
    /**/ i(string, get_cvars_s) \
    /**/
float get_cvars_f;
string get_cvars_s;
MUTATOR_HOOKABLE(GetCvars, EV_NO_ARGS); // NOTE: Can't use EV_GetCvars because of `SZ_GetSpace: overflow`

/** can edit any "just fired" projectile */
#define EV_EditProjectile(i, o) \
    /**/ i(entity, __self) \
    /**/ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(EditProjectile, EV_EditProjectile);

/** called when a monster spawns */
MUTATOR_HOOKABLE(MonsterSpawn, EV_NO_ARGS);

/** called when a monster dies */
#define EV_MonsterDies(i, o) \
    /**/ i(entity, frag_attacker) \
    /**/
MUTATOR_HOOKABLE(MonsterDies, EV_MonsterDies);

/** called when a monster dies */
#define EV_MonsterRemove(i, o) \
    /**/ i(entity, rem_mon) \
    /**/
entity rem_mon; // avoiding ovewriting self & other
MUTATOR_HOOKABLE(MonsterRemove, EV_MonsterRemove);

/** called when a monster wants to respawn */
#define EV_MonsterRespawn(i, o) \
    /**/ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(MonsterRespawn, EV_MonsterRespawn);

/** called when a monster is dropping loot */
#define EV_MonsterDropItem(i, o) \
    /**/ i(entity, other) \
    /**/ o(entity, other) \
    /**/
.void(entity this) monster_loot;
MUTATOR_HOOKABLE(MonsterDropItem, EV_MonsterDropItem);

/**
 * called when a monster moves
 * returning true makes the monster stop
 */
#define EV_MonsterMove(i, o) \
    /**/ i(float, monster_speed_run) \
    /**/ o(float, monster_speed_run) \
    /**/ i(float, monster_speed_walk) \
    /**/ o(float, monster_speed_walk) \
    /**/ i(entity, monster_target) \
    /**/
float monster_speed_run;
float monster_speed_walk;
entity monster_target;
MUTATOR_HOOKABLE(MonsterMove, EV_MonsterMove);

/** called when a monster looks for another target */
MUTATOR_HOOKABLE(MonsterFindTarget, EV_NO_ARGS);

/** called to change a random monster to a miniboss */
MUTATOR_HOOKABLE(MonsterCheckBossFlag, EV_NO_ARGS);

/**
 * called when a player tries to spawn a monster
 * return 1 to prevent spawning
 */
MUTATOR_HOOKABLE(AllowMobSpawning, EV_NO_ARGS);

/** called when a player gets damaged to e.g. remove stuff he was carrying. */
#define EV_PlayerDamage_SplitHealthArmor(i, o) \
    /**/ i(entity, frag_inflictor) \
    /**/ i(entity, frag_attacker) \
    /** same as self */ i(entity, frag_target) \
    /** NOTE: this force already HAS been applied */ i(vector, damage_force) \
    /**/ i(float, damage_take) \
    /**/ o(float, damage_take) \
	/**/ i(float, damage_save) \
    /**/ o(float, damage_save) \
    /**/
vector damage_force;
float damage_take;
float damage_save;
MUTATOR_HOOKABLE(PlayerDamage_SplitHealthArmor, EV_PlayerDamage_SplitHealthArmor);

/**
 * called to adjust damage and force values which are applied to the player, used for e.g. strength damage/force multiplier
 * i'm not sure if I should change this around slightly (Naming of the entities, and also how they're done in g_damage).
 */
#define EV_PlayerDamage_Calculate(i, o) \
    /**/ i(entity, frag_inflictor) \
    /**/ i(entity, frag_attacker) \
    /**/ i(entity, frag_target) \
    /**/ i(float, frag_deathtype) \
 	/**/ i(float, frag_damage) \
    /**/ o(float, frag_damage) \
 	/**/ i(float, frag_mirrordamage) \
    /**/ o(float, frag_mirrordamage) \
    /**/ i(vector, frag_force) \
    /**/ o(vector, frag_force) \
    /**/
float frag_damage;
float frag_mirrordamage;
vector frag_force;
MUTATOR_HOOKABLE(PlayerDamage_Calculate, EV_PlayerDamage_Calculate);

/**
 * Called when a player is damaged
 */
#define EV_PlayerDamaged(i, o) \
    /** attacker  */ i(entity, MUTATOR_ARGV_0_entity) \
    /** target    */ i(entity, MUTATOR_ARGV_1_entity) \
    /** health    */ i(int,    MUTATOR_ARGV_0_int) \
    /** armor     */ i(int,    MUTATOR_ARGV_1_int) \
    /** location  */ i(vector, MUTATOR_ARGV_0_vector) \
    /** deathtype */ i(int,    MUTATOR_ARGV_2_int) \
    /**/
MUTATOR_HOOKABLE(PlayerDamaged, EV_PlayerDamaged);

/**
 * Called by W_DecreaseAmmo
 */
#define EV_W_DecreaseAmmo(i, o) \
    /** actor */ i(entity, MUTATOR_ARGV_0_entity) \
    /**/
MUTATOR_HOOKABLE(W_DecreaseAmmo, EV_W_DecreaseAmmo);

/**
 * Called by W_Reload
 */
#define EV_W_Reload(i, o) \
    /** actor */ i(entity, MUTATOR_ARGV_0_entity) \
    /**/
MUTATOR_HOOKABLE(W_Reload, EV_W_Reload);

/** called at the end of player_powerups() in cl_client.qc, used for manipulating the values which are set by powerup items. */
#define EV_PlayerPowerups(i, o) \
    /**/ i(entity, __self) \
    /**/ i(int, olditems) \
    /**/
int olditems;
MUTATOR_HOOKABLE(PlayerPowerups, EV_PlayerPowerups);

/**
 * called every player think frame
 * return 1 to disable regen
 */
float regen_mod_max;
float regen_mod_regen;
float regen_mod_rot;
float regen_mod_limit;
float regen_health;
float regen_health_linear;
float regen_health_rot;
float regen_health_rotlinear;
float regen_health_stable;
float regen_health_rotstable;
MUTATOR_HOOKABLE(PlayerRegen, EV_NO_ARGS);

/**
 * called when the use key is pressed
 * if MUTATOR_RETURNVALUE is 1, don't do anything
 * return 1 if the use key actually did something
 */
MUTATOR_HOOKABLE(PlayerUseKey, EV_NO_ARGS);

/**
 * called when a client command is parsed
 * NOTE: hooks MUST start with if (MUTATOR_RETURNVALUE) return false;
 * NOTE: return true if you handled the command, return false to continue handling
 * NOTE: THESE HOOKS MUST NEVER EVER CALL tokenize()
 * // example:
 * MUTATOR_HOOKFUNCTION(foo_SV_ParseClientCommand)
 * {
 *     if (MUTATOR_RETURNVALUE) // command was already handled?
 *         return false;
 *     if (cmd_name == "echocvar" && cmd_argc >= 2)
 *     {
 *         print(cvar_string(argv(1)), "\n");
 *         return true;
 *     }
 *     if (cmd_name == "echostring" && cmd_argc >= 2)
 *     {
 *         print(substring(cmd_string, argv_start_index(1), argv_end_index(-1) - argv_start_index(1)), "\n");
 *         return true;
 *     }
 *     return false;
 * }
 */
#define EV_SV_ParseClientCommand(i, o) \
    /** command name */ i(string, cmd_name) \
    /** also, argv() can be used */ i(int, cmd_argc) \
    /** whole command, use only if you really have to */ i(string, cmd_string) \
    /**/
string cmd_name;
int cmd_argc;
string cmd_string;
MUTATOR_HOOKABLE(SV_ParseClientCommand, EV_SV_ParseClientCommand);

/** please read EV_SV_ParseClientCommand description before using */
#define EV_SV_ParseServerCommand(i, o) \
    /** command name */ i(string, cmd_name) \
    /** also, argv() can be used */ i(int, cmd_argc) \
    /** whole command, use only if you really have to */ i(string, cmd_string) \
    /**/
//string cmd_name;
//int cmd_argc;
//string cmd_string;
MUTATOR_HOOKABLE(SV_ParseServerCommand, EV_SV_ParseServerCommand);

/**
 * called when a spawnpoint is being evaluated
 * return 1 to make the spawnpoint unusable
 */
#define EV_Spawn_Score(i, o) \
    /** player wanting to spawn */ i(entity, __self) \
    /** spot to be evaluated */ i(entity, spawn_spot) \
    /** _x is priority, _y is "distance" */ i(vector, spawn_score) \
    /**/ o(vector, spawn_score) \
    /**/
vector spawn_score;
MUTATOR_HOOKABLE(Spawn_Score, EV_Spawn_Score);

/** runs globally each server frame */
MUTATOR_HOOKABLE(SV_StartFrame, EV_NO_ARGS);

#define EV_SetModname(i, o) \
    /** name of the mutator/mod if it warrants showing as such in the server browser */ \
    o(string, modname) \
    /**/
MUTATOR_HOOKABLE(SetModname, EV_SetModname);

/**
 * called for each item being spawned on a map, including dropped weapons
 * return 1 to remove an item
 */
#define EV_Item_Spawn(i, o) \
    /** the item */ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(Item_Spawn, EV_Item_Spawn);

#define EV_SetWeaponreplace(i, o) \
    /** map entity */ i(entity, __self) \
    /** weapon info */ i(entity, other) \
    /**/ i(string, ret_string) \
    /**/ o(string, ret_string) \
    /**/
MUTATOR_HOOKABLE(SetWeaponreplace, EV_SetWeaponreplace);

/** called when an item is about to respawn */
#define EV_Item_RespawnCountdown(i, o) \
    /**/ i(string, item_name) \
    /**/ o(string, item_name) \
    /**/ i(vector, item_color) \
    /**/ o(vector, item_color) \
    /**/
string item_name;
vector item_color;
MUTATOR_HOOKABLE(Item_RespawnCountdown, EV_Item_RespawnCountdown);

/** called when a bot checks a target to attack */
#define EV_BotShouldAttack(i, o) \
    /**/ i(entity, checkentity) \
    /**/
entity checkentity;
MUTATOR_HOOKABLE(BotShouldAttack, EV_BotShouldAttack);

/**
 * called whenever a player goes through a portal gun teleport
 * allows you to strip a player of an item if they go through the teleporter to help prevent cheating
 */
#define EV_PortalTeleport(i, o) \
    /**/ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(PortalTeleport, EV_PortalTeleport);

/**
 * called whenever a player uses impulse 33 (help me) in cl_impulse.qc
 * normally help me ping uses self.waypointsprite_attachedforcarrier,
 * but if your mutator uses something different then you can handle it
 * in a special manner using this hook
 */
#define EV_HelpMePing(i, o) \
    /** the player who pressed impulse 33 */ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(HelpMePing, EV_HelpMePing);

/**
 * called when a vehicle initializes
 * return true to remove the vehicle
 */
MUTATOR_HOOKABLE(VehicleSpawn, EV_NO_ARGS);

/**
 * called when a player enters a vehicle
 * allows mutators to set special settings in this event
 */
#define EV_VehicleEnter(i, o) \
    /** player */ i(entity, vh_player) \
    /** vehicle */ i(entity, vh_vehicle) \
    /**/
entity vh_player;
entity vh_vehicle;
MUTATOR_HOOKABLE(VehicleEnter, EV_VehicleEnter);

/**
 * called when a player touches a vehicle
 * return true to stop player from entering the vehicle
 */
#define EV_VehicleTouch(i, o) \
    /** vehicle */ i(entity, __self) \
    /** player */ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(VehicleTouch, EV_VehicleTouch);

/**
 * called when a player exits a vehicle
 * allows mutators to set special settings in this event
 */
#define EV_VehicleExit(i, o) \
    /** player */ i(entity, vh_player) \
    /** vehicle */ i(entity, vh_vehicle) \
    /**/
MUTATOR_HOOKABLE(VehicleExit, EV_VehicleExit);

/** called when a speedrun is aborted and the player is teleported back to start position */
#define EV_AbortSpeedrun(i, o) \
    /** player */ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(AbortSpeedrun, EV_AbortSpeedrun);

/** called at when a item is touched. Called early, can edit item properties. */
#define EV_ItemTouch(i, o) \
    /** item */ i(entity, __self) \
    /** player */ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(ItemTouch, EV_ItemTouch);

enum {
	MUT_ITEMTOUCH_CONTINUE, // return this flag to make the function continue as normal
	MUT_ITEMTOUCH_RETURN, // return this flag to make the function return (handled entirely by mutator)
	MUT_ITEMTOUCH_PICKUP // return this flag to have the item "picked up" and taken even after mutator handled it
};

/** called at when a player connect */
#define EV_ClientConnect(i, o) \
    /** player */ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(ClientConnect, EV_ClientConnect);

#define EV_HavocBot_ChooseRole(i, o) \
    /**/ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(HavocBot_ChooseRole, EV_HavocBot_ChooseRole);

/** called when a target is checked for accuracy */
#define EV_AccuracyTargetValid(i, o) \
    /** attacker */ i(entity, frag_attacker) \
    /** target */ i(entity, frag_target) \
    /**/
MUTATOR_HOOKABLE(AccuracyTargetValid, EV_AccuracyTargetValid);
enum {
	MUT_ACCADD_VALID, // return this flag to make the function continue if target is a client
	MUT_ACCADD_INVALID, // return this flag to make the function always continue
	MUT_ACCADD_INDIFFERENT // return this flag to make the function always return
};

/** Called when clearing the global parameters for a model */
MUTATOR_HOOKABLE(ClearModelParams, EV_NO_ARGS);

/** Called when getting the global parameters for a model */
#define EV_GetModelParams(i, o) \
    /** entity id */ i(string, checkmodel_input) \
    /** entity id */ i(string, checkmodel_command) \
    /**/
string checkmodel_input, checkmodel_command;
MUTATOR_HOOKABLE(GetModelParams, EV_GetModelParams);

/** called when a bullet has hit a target */
#define EV_FireBullet_Hit(i, o) \
    /**/ i(entity, __self) \
    /**/ i(entity, bullet_hit) \
    /**/ i(vector, bullet_startpos) \
    /**/ i(vector, bullet_endpos) \
    /**/ i(float, frag_damage) \
    /**/ o(float, frag_damage) \
    /**/
entity bullet_hit;
//vector bullet_hitloc; // the end pos matches the hit location, apparently
vector bullet_startpos;
vector bullet_endpos;
//float frag_damage;
MUTATOR_HOOKABLE(FireBullet_Hit, EV_FireBullet_Hit);

#define EV_FixPlayermodel(i, o) \
    /**/ i(string, ret_string) \
    /**/ o(string, ret_string) \
    /**/ i(int, ret_int) \
    /**/ o(int, ret_int) \
    /**/
int ret_int;
MUTATOR_HOOKABLE(FixPlayermodel, EV_FixPlayermodel);

/** Return error to play frag remaining announcements */
MUTATOR_HOOKABLE(Scores_CountFragsRemaining, EV_NO_ARGS);

#define EV_GrappleHookThink(i, o) \
    /**/ i(entity, __self) \
    /**/ i(int, hook_tarzan) \
    /**/ o(int, hook_tarzan) \
    /**/ i(entity, hook_pullentity) \
    /**/ o(entity, hook_pullentity) \
    /**/ i(float, hook_velmultiplier) \
    /**/ o(float, hook_velmultiplier) \
    /**/
int hook_tarzan;
entity hook_pullentity;
float hook_velmultiplier;
MUTATOR_HOOKABLE(GrappleHookThink, EV_GrappleHookThink);

#define EV_BuffModel_Customize(i, o) \
    /**/ i(entity, __self) \
    /**/ i(entity, buff_player) \
    /**/
entity buff_player;
MUTATOR_HOOKABLE(BuffModel_Customize, EV_BuffModel_Customize);

/** called at when a buff is touched. Called early, can edit buff properties. */
#define EV_BuffTouch(i, o) \
    /** item */ i(entity, __self) \
    /** player */ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(BuffTouch, EV_BuffTouch);

MUTATOR_HOOKABLE(SetNewParms, EV_NO_ARGS);

MUTATOR_HOOKABLE(SetChangeParms, EV_NO_ARGS);

MUTATOR_HOOKABLE(DecodeLevelParms, EV_NO_ARGS);

#define EV_GetRecords(i, o) \
    /**/ i(int, record_page) \
    /**/ i(string, ret_string) \
    /**/ o(string, ret_string) \
    /**/
int record_page;
MUTATOR_HOOKABLE(GetRecords, EV_GetRecords);

#define EV_Race_FinalCheckpoint(i, o) \
    /**/ i(entity, race_player) \
    /**/
entity race_player;
MUTATOR_HOOKABLE(Race_FinalCheckpoint, EV_Race_FinalCheckpoint);

/** called when player triggered kill (or is changing teams), return error to not do anything */
#define EV_ClientKill(i, o) \
    /** player */ i(entity, __self) \
    /* kill delay */ i(float, ret_float) \
    /* kill delay */ o(float, ret_float) \
    /**/
MUTATOR_HOOKABLE(ClientKill, EV_ClientKill);

#define EV_FixClientCvars(i, o) \
    /**/ i(entity, fix_client) \
    /**/
entity fix_client;
MUTATOR_HOOKABLE(FixClientCvars, EV_FixClientCvars);

#define EV_SpectateSet(i, o) \
    /**/ i(entity, __self) \
    /**/ i(entity, spec_player) \
    /**/ o(entity, spec_player) \
    /**/
entity spec_player;
MUTATOR_HOOKABLE(SpectateSet, EV_SpectateSet);

#define EV_SpectateNext(i, o) \
    /**/ i(entity, __self) \
    /**/ i(entity, spec_player) \
    /**/ o(entity, spec_player) \
    /**/
MUTATOR_HOOKABLE(SpectateNext, EV_SpectateNext);

#define EV_SpectatePrev(i, o) \
    /**/ i(entity, __self) \
    /**/ i(entity, spec_player) \
    /**/ o(entity, spec_player) \
    /**/ i(entity, spec_first) \
    /**/
entity spec_first;
MUTATOR_HOOKABLE(SpectatePrev, EV_SpectatePrev);

enum {
    MUT_SPECPREV_CONTINUE, // return this flag to make the function continue as normal
    MUT_SPECPREV_RETURN, // return this flag to make the function return (handled entirely by mutator)
    MUT_SPECPREV_FOUND // return this flag to make the function continue without default functions (handled mostly by mutator)
};

/** called when player triggered kill (or is changing teams), return error to not do anything */
#define EV_Bot_FixCount(i, o) \
    /**/ i(int, bot_activerealplayers) \
    /**/ o(int, bot_activerealplayers) \
    /**/ i(int, bot_realplayers) \
    /**/ o(int, bot_realplayers) \
    /**/
int bot_activerealplayers;
int bot_realplayers;
MUTATOR_HOOKABLE(Bot_FixCount, EV_Bot_FixCount);

#define EV_ClientCommand_Spectate(i, o) \
    /**/ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(ClientCommand_Spectate, EV_ClientCommand_Spectate);

enum {
    MUT_SPECCMD_CONTINUE, // return this flag to make the function continue as normal
    MUT_SPECCMD_RETURN, // return this flag to make the function return (don't spectate)
    MUT_SPECCMD_FORCE // return this flag to force the player to spectate, even if they're not a player
};

#define EV_CheckRules_World(i, o) \
    /* status */ i(float, ret_float) \
    /* status */ o(float, ret_float) \
    /* time limit */ i(float, checkrules_timelimit) \
    /* frag limit */ i(int, checkrules_fraglimit) \
    /**/
float checkrules_timelimit;
int checkrules_fraglimit;
MUTATOR_HOOKABLE(CheckRules_World, EV_CheckRules_World);

#define EV_WantWeapon(i, o) \
    /**/ i(entity, want_weaponinfo) \
    /**/ i(float, ret_float) \
    /**/ o(float, ret_float) \
    /**/ i(bool, want_allguns) \
    /**/ o(bool, want_allguns) \
    /**/ i(bool, want_mutatorblocked) \
    /**/ o(bool, want_mutatorblocked) \
    /**/
entity want_weaponinfo;
bool want_allguns;
bool want_mutatorblocked;
MUTATOR_HOOKABLE(WantWeapon, EV_WantWeapon);

#define EV_AddPlayerScore(i, o) \
    /**/ i(int, score_field) \
    /**/ i(float, ret_float) \
    /**/ o(float, ret_float) \
    /**/
int score_field;
MUTATOR_HOOKABLE(AddPlayerScore, EV_AddPlayerScore);

#define EV_GetPlayerStatus(i, o) \
    /**/ i(entity, set_player) \
    /**/ i(string, ret_string) \
    /**/ o(string, ret_string) \
    /**/
entity set_player;
MUTATOR_HOOKABLE(GetPlayerStatus, EV_GetPlayerStatus);

#define EV_SetWeaponArena(i, o) \
    /**/ i(string, ret_string) \
    /**/ o(string, ret_string) \
    /**/
MUTATOR_HOOKABLE(SetWeaponArena, EV_SetWeaponArena);

#define EV_DropSpecialItems(i, o) \
    /**/ i(entity, frag_target) \
    /**/
MUTATOR_HOOKABLE(DropSpecialItems, EV_DropSpecialItems);

/**
 * called when an admin tries to kill all monsters
 * return 1 to prevent spawning
 */
MUTATOR_HOOKABLE(AllowMobButcher, EV_NO_ARGS);

MUTATOR_HOOKABLE(ReadLevelCvars, EV_NO_ARGS);

#define EV_SendWaypoint(i, o) \
    /**/ i(entity, __self) \
    /**/ i(entity, wp_sendto) \
    /**/ i(int, wp_sendflags) \
    /**/ o(int, wp_sendflags) \
    /**/ i(int, wp_flag) \
    /**/ o(int, wp_flag) \
    /**/
entity wp_sendto;
int wp_sendflags;
int wp_flag;
MUTATOR_HOOKABLE(SendWaypoint, EV_SendWaypoint);

#define EV_TurretValidateTarget(i, o) \
    /**/ i(entity, turret_this) \
    /**/ i(entity, turret_target) \
    /**/ i(int, turret_vflags) \
    /**/
entity turret_this;
entity turret_target;
int turret_vflags;
MUTATOR_HOOKABLE(TurretValidateTarget, EV_TurretValidateTarget);

#define EV_TurretThink(i, o) \
    /**/ i(entity, __self) \
    /**/
MUTATOR_HOOKABLE(TurretThink, EV_TurretThink);

MUTATOR_HOOKABLE(Ent_Init, EV_NO_ARGS);

/** */
#define EV_PrepareExplosionByDamage(i, o) \
    /**/ i(entity, __self) \
    /**/ i(entity, frag_attacker) \
    /**/
MUTATOR_HOOKABLE(PrepareExplosionByDamage, EV_PrepareExplosionByDamage);

/** called when a monster model is about to be set, allows custom paths etc. */
#define EV_MonsterModel(i, o) \
    /**/ i(string, monster_model) \
    /**/ i(string, monster_model_output) \
    /**/ o(string, monster_model_output) \
    /**/
string monster_model;
string monster_model_output;
MUTATOR_HOOKABLE(MonsterModel, EV_MonsterModel);

/**/
#define EV_Player_ChangeTeam(i, o) \
    /**/ i(entity, __self) \
    /**/ i(float, pct_curteam) \
    /**/ i(float, pct_newteam) \
    /**/
float pct_curteam;
float pct_newteam;
MUTATOR_HOOKABLE(Player_ChangeTeam, EV_Player_ChangeTeam);
#endif
