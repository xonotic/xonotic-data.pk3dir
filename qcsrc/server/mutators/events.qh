#ifndef SERVER_MUTATORS_EVENTS_H
#define SERVER_MUTATORS_EVENTS_H

#include "../../common/mutators/base.qh"

// register all possible hooks here

/** called when a player becomes observer, after shared setup */
#define EV_MakePlayerObserver(i, o) \
    /**/
MUTATOR_HOOKABLE(MakePlayerObserver, EV_MakePlayerObserver)

/** */
#define EV_PutClientInServer(i, o) \
    /** client wanting to spawn */ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(PutClientInServer, EV_PutClientInServer);

/** called when a player spawns as player, after shared setup, before his weapon is chosen (so items may be changed in here) */
#define EV_PlayerSpawn(i, o) \
    /** spot that was used, or world */ i(entity, spawn_spot) \
    /**/
entity spawn_spot;
MUTATOR_HOOKABLE(PlayerSpawn, EV_PlayerSpawn);

/** called in reset_map */
#define EV_reset_map_global(i, o) \
    /**/
MUTATOR_HOOKABLE(reset_map_global, EV_reset_map_global);

/** called in reset_map */
#define EV_reset_map_players(i, o) \
    /**/
MUTATOR_HOOKABLE(reset_map_players, EV_reset_map_players);

/** returns 1 if clearing player score shall not be allowed */
#define EV_ForbidPlayerScore_Clear(i, o) \
    /**/
MUTATOR_HOOKABLE(ForbidPlayerScore_Clear, EV_ForbidPlayerScore_Clear);

/** called when a player disconnects */
#define EV_ClientDisconnect(i, o) \
    /**/
MUTATOR_HOOKABLE(ClientDisconnect, EV_ClientDisconnect);

/** called when a player dies to e.g. remove stuff he was carrying. */
#define EV_PlayerDies(i, o) \
    /**/ i(entity, frag_inflictor) \
    /**/ i(entity, frag_attacker) \
    /** same as self */ i(entity, frag_target) \
    /**/ i(int, frag_deathtype) \
    /**/
entity frag_inflictor;
entity frag_attacker;
entity frag_target;
int frag_deathtype;
MUTATOR_HOOKABLE(PlayerDies, EV_PlayerDies);

/** called when a player dies to e.g. remove stuff he was carrying */
#define EV_PlayHitsound(i, o) \
    /**/ i(entity, frag_victim) \
    /**/
entity frag_victim;
MUTATOR_HOOKABLE(PlayHitsound, EV_PlayHitsound);

/** called when a weapon sound is about to be played, allows custom paths etc. */
#define EV_WeaponSound(i, o) \
    /**/ i(string, weapon_sound) \
    /**/ i(string, weapon_sound_output) \
    /**/ o(string, weapon_sound_output) \
    /**/
string weapon_sound;
string weapon_sound_output;
MUTATOR_HOOKABLE(WeaponSound, EV_WeaponSound);

/** called when a weapon model is about to be set, allows custom paths etc. */
#define EV_WeaponModel(i, o) \
    /**/ i(string, weapon_model) \
    /**/ i(string, weapon_model_output) \
    /**/ o(string, weapon_model_output) \
    /**/
string weapon_model;
string weapon_model_output;
MUTATOR_HOOKABLE(WeaponModel, EV_WeaponModel);

/** called when an item model is about to be set, allows custom paths etc. */
#define EV_ItemModel(i, o) \
    /**/ i(string, item_model) \
    /**/ i(string, item_model_output) \
    /**/ o(string, item_model_output) \
    /**/
string item_model;
string item_model_output;
MUTATOR_HOOKABLE(ItemModel, EV_ItemModel);

/** called when a player presses the jump key */
#define EV_PlayerJump(i, o) \
    /**/ i(float, player_multijump) \
    /**/ i(float, player_jumpheight) \
    /**/ o(float, player_multijump) \
    /**/ o(float, player_jumpheight) \
    /**/
float player_multijump;
float player_jumpheight;
MUTATOR_HOOKABLE(PlayerJump, EV_PlayerJump);

/** called when someone was fragged by "self", and is expected to change frag_score to adjust scoring for the kill */
#define EV_GiveFragsForKill(i, o) \
    /** same as self */ i(entity, frag_attacker) \
    /**/ i(entity, frag_target) \
    /**/ i(float, frag_score) \
    /**/ o(float, frag_score) \
    /**/
float frag_score;
MUTATOR_HOOKABLE(GiveFragsForKill, EV_GiveFragsForKill);

/** called when the match ends */
MUTATOR_HOOKABLE(MatchEnd, EV_NO_ARGS);

/** should adjust ret_float to contain the team count */
#define EV_GetTeamCount(i, o) \
    /**/ i(float, ret_float) \
    /**/ o(float, ret_float) \
    /**/
float ret_float;
MUTATOR_HOOKABLE(GetTeamCount, EV_GetTeamCount);

/** copies variables for spectating "other" to "self" */
#define EV_SpectateCopy(i, o) \
    /**/ i(entity, other) \
    /**/ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(SpectateCopy, EV_SpectateCopy);

/** called when formatting a chat message to replace fancy functions */
#define EV_FormatMessage(i, o) \
    /**/ i(string, format_escape) \
    /**/ i(string, format_replacement) \
    /**/ o(string, format_replacement) \
    /**/
string format_escape;
string format_replacement;
MUTATOR_HOOKABLE(FormatMessage, EV_FormatMessage);

/** returns 1 if throwing the current weapon shall not be allowed */
MUTATOR_HOOKABLE(ForbidThrowCurrentWeapon, EV_NO_ARGS);

/** allows changing attack rate */
#define EV_WeaponRateFactor(i, o) \
    /**/ i(float, weapon_rate) \
    /**/ o(float, weapon_rate) \
    /**/
float weapon_rate;
MUTATOR_HOOKABLE(WeaponRateFactor, EV_WeaponRateFactor);

/** allows changing weapon speed (projectiles mostly) */
#define EV_WeaponSpeedFactor(i, o) \
    /**/ i(float, ret_float) \
    /**/ o(float, ret_float) \
    /**/
MUTATOR_HOOKABLE(WeaponSpeedFactor, EV_WeaponSpeedFactor);

/** adjusts {warmup_}start_{items,weapons,ammo_{cells,plasma,rockets,nails,shells,fuel}} */
MUTATOR_HOOKABLE(SetStartItems, EV_NO_ARGS);

/** called every frame. customizes the waypoint for spectators */
#define EV_CustomizeWaypoint(i, o) \
    /** waypoint */ i(entity, self) \
    /** player; other.enemy = spectator */ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(CustomizeWaypoint, EV_CustomizeWaypoint);

/**
 * checks if the current item may be spawned (self.items and self.weapons may be read and written to, as well as the ammo_ fields)
 * return error to request removal
 */
MUTATOR_HOOKABLE(FilterItem, EV_NO_ARGS);

/** return error to request removal */
#define EV_TurretSpawn(i, o) \
    /** turret */ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(TurretSpawn, EV_TurretSpawn);

/** return error to prevent entity spawn, or modify the entity */
MUTATOR_HOOKABLE(OnEntityPreSpawn, EV_NO_ARGS);

/** runs in the event loop for players; is called for ALL player entities, also bots, also the dead, or spectators */
MUTATOR_HOOKABLE(PlayerPreThink, EV_NO_ARGS);

/** TODO change this into a general PlayerPostThink hook? */
MUTATOR_HOOKABLE(GetPressedKeys, EV_NO_ARGS);

/**
 * called before any player physics, may adjust variables for movement,
 * is run AFTER bot code and idle checking
 */
MUTATOR_HOOKABLE(PlayerPhysics, EV_NO_ARGS);

/** is meant to call GetCvars_handle*(get_cvars_s, get_cvars_f, cvarfield, "cvarname") for cvars this mutator needs from the client */
#define EV_GetCvars(i, o) \
    /**/ i(float, get_cvars_f) \
    /**/ i(string, get_cvars_s) \
    /**/
float get_cvars_f;
string get_cvars_s;
MUTATOR_HOOKABLE(GetCvars, EV_NO_ARGS); // NOTE: Can't use EV_GetCvars because of `SZ_GetSpace: overflow`

/** can edit any "just fired" projectile */
#define EV_EditProjectile(i, o) \
    /**/ i(entity, self) \
    /**/ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(EditProjectile, EV_EditProjectile);

/** called when a monster spawns */
MUTATOR_HOOKABLE(MonsterSpawn, EV_NO_ARGS);

/** called when a monster dies */
#define EV_MonsterDies(i, o) \
    /**/ i(entity, frag_attacker) \
    /**/
MUTATOR_HOOKABLE(MonsterDies, EV_MonsterDies);

/** called when a monster wants to respawn */
#define EV_MonsterRespawn(i, o) \
    /**/ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(MonsterRespawn, EV_MonsterRespawn);

/** called when a monster is dropping loot */
#define EV_MonsterDropItem(i, o) \
    /**/ i(entity, other) \
    /**/ o(entity, other) \
    /**/
.void() monster_loot;
MUTATOR_HOOKABLE(MonsterDropItem, EV_MonsterDropItem);

/**
 * called when a monster moves
 * returning true makes the monster stop
 */
#define EV_MonsterMove(i, o) \
    /**/ i(float, monster_speed_run) \
    /**/ o(float, monster_speed_run) \
    /**/ i(float, monster_speed_walk) \
    /**/ o(float, monster_speed_walk) \
    /**/ i(entity, monster_target) \
    /**/
float monster_speed_run;
float monster_speed_walk;
entity monster_target;
MUTATOR_HOOKABLE(MonsterMove, EV_MonsterMove);

/** called when a monster looks for another target */
MUTATOR_HOOKABLE(MonsterFindTarget, EV_NO_ARGS);

/** called to change a random monster to a miniboss */
MUTATOR_HOOKABLE(MonsterCheckBossFlag, EV_NO_ARGS);

/**
 * called when a player tries to spawn a monster
 * return 1 to prevent spawning
 */
MUTATOR_HOOKABLE(AllowMobSpawning, EV_NO_ARGS);

/** called when a player gets damaged to e.g. remove stuff he was carrying. */
#define EV_PlayerDamage_SplitHealthArmor(i, o) \
    /**/ i(entity, frag_inflictor) \
    /**/ i(entity, frag_attacker) \
    /** same as self */ i(entity, frag_target) \
    /** NOTE: this force already HAS been applied */ i(vector, damage_force) \
    /**/ i(float, damage_take) \
    /**/ o(float, damage_take) \
	/**/ i(float, damage_save) \
    /**/ o(float, damage_save) \
    /**/
vector damage_force;
float damage_take;
float damage_save;
MUTATOR_HOOKABLE(PlayerDamage_SplitHealthArmor, EV_PlayerDamage_SplitHealthArmor);

/**
 * called to adjust damage and force values which are applied to the player, used for e.g. strength damage/force multiplier
 * i'm not sure if I should change this around slightly (Naming of the entities, and also how they're done in g_damage).
 */
#define EV_PlayerDamage_Calculate(i, o) \
    /**/ i(entity, frag_attacker) \
    /**/ i(entity, frag_target) \
    /**/ i(float, frag_deathtype) \
 	/**/ i(float, frag_damage) \
    /**/ o(float, frag_damage) \
 	/**/ i(float, frag_mirrordamage) \
    /**/ o(float, frag_mirrordamage) \
    /**/ i(vector, frag_force) \
    /**/ o(vector, frag_force) \
    /**/
float frag_damage;
float frag_mirrordamage;
vector frag_force;
MUTATOR_HOOKABLE(PlayerDamage_Calculate, EV_PlayerDamage_Calculate);

/**
 * Called when a player is damaged
 */
#define EV_PlayerDamaged(i, o) \
    /** attacker */ i(entity, mutator_argv_entity_0) \
    /** target */ i(entity, mutator_argv_entity_1) \
    /** health */ i(int, mutator_argv_int_0) \
    /** armor */ i(int, mutator_argv_int_1) \
    /** location */ i(vector, mutator_argv_vector_0) \
    /**/
MUTATOR_HOOKABLE(PlayerDamaged, EV_PlayerDamaged);

/** called at the end of player_powerups() in cl_client.qc, used for manipulating the values which are set by powerup items. */
#define EV_PlayerPowerups(i, o) \
    /**/ i(entity, self) \
    /**/ i(int, olditems) \
    /**/
int olditems;
MUTATOR_HOOKABLE(PlayerPowerups, EV_PlayerPowerups);

/**
 * called every player think frame
 * return 1 to disable regen
 */
#define EV_PlayerRegen(i, o) \
    /**/ i(float, regen_mod_max) \
    /**/ o(float, regen_mod_max) \
    /**/ i(float, regen_mod_regen) \
    /**/ o(float, regen_mod_regen) \
    /**/ i(float, regen_mod_rot) \
    /**/ o(float, regen_mod_rot) \
    /**/ i(float, regen_mod_limit) \
    /**/ o(float, regen_mod_limit) \
    /**/
float regen_mod_max;
float regen_mod_regen;
float regen_mod_rot;
float regen_mod_limit;
MUTATOR_HOOKABLE(PlayerRegen, EV_PlayerRegen);

/**
 * called when the use key is pressed
 * if MUTATOR_RETURNVALUE is 1, don't do anything
 * return 1 if the use key actually did something
 */
MUTATOR_HOOKABLE(PlayerUseKey, EV_NO_ARGS);

/**
 * called when a client command is parsed
 * NOTE: hooks MUST start with if (MUTATOR_RETURNVALUE) return false;
 * NOTE: return true if you handled the command, return false to continue handling
 * NOTE: THESE HOOKS MUST NEVER EVER CALL tokenize()
 * // example:
 * MUTATOR_HOOKFUNCTION(foo_SV_ParseClientCommand)
 * {
 *     if (MUTATOR_RETURNVALUE) // command was already handled?
 *         return false;
 *     if (cmd_name == "echocvar" && cmd_argc >= 2)
 *     {
 *         print(cvar_string(argv(1)), "\n");
 *         return true;
 *     }
 *     if (cmd_name == "echostring" && cmd_argc >= 2)
 *     {
 *         print(substring(cmd_string, argv_start_index(1), argv_end_index(-1) - argv_start_index(1)), "\n");
 *         return true;
 *     }
 *     return false;
 * }
 */
#define EV_SV_ParseClientCommand(i, o) \
    /** command name */ i(string, cmd_name) \
    /** also, argv() can be used */ i(int, cmd_argc) \
    /** whole command, use only if you really have to */ i(string, cmd_string) \
    /**/
string cmd_name;
int cmd_argc;
string cmd_string;
MUTATOR_HOOKABLE(SV_ParseClientCommand, EV_SV_ParseClientCommand);

/**
 * called when a spawnpoint is being evaluated
 * return 1 to make the spawnpoint unusable
 */
#define EV_Spawn_Score(i, o) \
    /** player wanting to spawn */ i(entity, self) \
    /** spot to be evaluated */ i(entity, spawn_spot) \
    /** _x is priority, _y is "distance" */ i(vector, spawn_score) \
    /**/ o(vector, spawn_score) \
    /**/
vector spawn_score;
MUTATOR_HOOKABLE(Spawn_Score, EV_Spawn_Score);

/** runs globally each server frame */
MUTATOR_HOOKABLE(SV_StartFrame, EV_NO_ARGS);

#define EV_SetModname(i, o) \
    /** name of the mutator/mod if it warrants showing as such in the server browser */ \
    o(string, modname) \
    /**/
MUTATOR_HOOKABLE(SetModname, EV_SetModname);

/**
 * called for each item being spawned on a map, including dropped weapons
 * return 1 to remove an item
 */
#define EV_Item_Spawn(i, o) \
    /** the item */ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(Item_Spawn, EV_Item_Spawn);

#define EV_SetWeaponreplace(i, o) \
    /** map entity */ i(entity, self) \
    /** weapon info */ i(entity, other) \
    /**/ i(string, ret_string) \
    /**/ o(string, ret_string) \
    /**/
MUTATOR_HOOKABLE(SetWeaponreplace, EV_SetWeaponreplace);

/** called when an item is about to respawn */
#define EV_Item_RespawnCountdown(i, o) \
    /**/ i(string, item_name) \
    /**/ o(string, item_name) \
    /**/ i(vector, item_color) \
    /**/ o(vector, item_color) \
    /**/
string item_name;
vector item_color;
MUTATOR_HOOKABLE(Item_RespawnCountdown, EV_Item_RespawnCountdown);

/** called when a bot checks a target to attack */
#define EV_BotShouldAttack(i, o) \
    /**/ i(entity, checkentity) \
    /**/
entity checkentity;
MUTATOR_HOOKABLE(BotShouldAttack, EV_BotShouldAttack);

/**
 * called whenever a player goes through a portal gun teleport
 * allows you to strip a player of an item if they go through the teleporter to help prevent cheating
 */
#define EV_PortalTeleport(i, o) \
    /**/ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(PortalTeleport, EV_PortalTeleport);

/**
 * called whenever a player uses impulse 33 (help me) in cl_impulse.qc
 * normally help me ping uses self.waypointsprite_attachedforcarrier,
 * but if your mutator uses something different then you can handle it
 * in a special manner using this hook
 */
#define EV_HelpMePing(i, o) \
    /** the player who pressed impulse 33 */ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(HelpMePing, EV_HelpMePing);

/**
 * called when a vehicle initializes
 * return true to remove the vehicle
 */
MUTATOR_HOOKABLE(VehicleSpawn, EV_NO_ARGS);

/**
 * called when a player enters a vehicle
 * allows mutators to set special settings in this event
 */
#define EV_VehicleEnter(i, o) \
    /** player */ i(entity, vh_player) \
    /** vehicle */ i(entity, vh_vehicle) \
    /**/
entity vh_player;
entity vh_vehicle;
MUTATOR_HOOKABLE(VehicleEnter, EV_VehicleEnter);

/**
 * called when a player touches a vehicle
 * return true to stop player from entering the vehicle
 */
#define EV_VehicleTouch(i, o) \
    /** vehicle */ i(entity, self) \
    /** player */ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(VehicleTouch, EV_VehicleTouch);

/**
 * called when a player exits a vehicle
 * allows mutators to set special settings in this event
 */
#define EV_VehicleExit(i, o) \
    /** player */ i(entity, vh_player) \
    /** vehicle */ i(entity, vh_vehicle) \
    /**/
MUTATOR_HOOKABLE(VehicleExit, EV_VehicleExit);

/** called when a speedrun is aborted and the player is teleported back to start position */
#define EV_AbortSpeedrun(i, o) \
    /** player */ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(AbortSpeedrun, EV_AbortSpeedrun);

/** called at when a item is touched. Called early, can edit item properties. */
#define EV_ItemTouch(i, o) \
    /** item */ i(entity, self) \
    /** player */ i(entity, other) \
    /**/
MUTATOR_HOOKABLE(ItemTouch, EV_ItemTouch);

enum {
	MUT_ITEMTOUCH_CONTINUE, // return this flag to make the function continue as normal
	MUT_ITEMTOUCH_RETURN, // return this flag to make the function return (handled entirely by mutator)
	MUT_ITEMTOUCH_PICKUP // return this flag to have the item "picked up" and taken even after mutator handled it
};

/** called at when a player connect */
#define EV_ClientConnect(i, o) \
    /** player */ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(ClientConnect, EV_ClientConnect);

#define EV_HavocBot_ChooseRole(i, o) \
    /**/ i(entity, self) \
    /**/
MUTATOR_HOOKABLE(HavocBot_ChooseRole, EV_HavocBot_ChooseRole);

/** called when a target is checked for accuracy */
#define EV_AccuracyTargetValid(i, o) \
    /** attacker */ i(entity, frag_attacker) \
    /** target */ i(entity, frag_target) \
    /**/
MUTATOR_HOOKABLE(AccuracyTargetValid, EV_AccuracyTargetValid);
enum {
	MUT_ACCADD_VALID, // return this flag to make the function continue if target is a client
	MUT_ACCADD_INVALID, // return this flag to make the function always continue
	MUT_ACCADD_INDIFFERENT // return this flag to make the function always return
};
#endif
