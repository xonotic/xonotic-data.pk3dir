#define CBC_ORDER_EXCLUSIVE 3
#define CBC_ORDER_FIRST 1
#define CBC_ORDER_LAST 2
#define CBC_ORDER_ANY 4

float CallbackChain_ReturnValue; // read-only field of the current return value

entity CallbackChain_New(string name);
float CallbackChain_Add(entity cb, float() func, float order)
float CallbackChain_Remove(entity cb, float() func);
// a callback function is like this:
// float mycallback(entity me)
// {
//   do something
//   return r;
// }
float CallbackChain_Call(entity cb);

#define MUTATOR_REMOVING 0
#define MUTATOR_ADDING 1
typedef float(float) mutatorfunc_t;
float Mutator_Add(mutatorfunc_t func, string name);
void Mutator_Remove(mutatorfunc_t func, string name); // calls error() on fail

#define MUTATOR_ADD(name) Mutator_Add(MUTATOR_##name, #name)
#define MUTATOR_REMOVE(name) Mutator_Remove(MUTATOR_##name, #name)
#define MUTATOR_DEFINITION(name) float MUTATOR_##name(float mode)
#define MUTATOR_DECLARATION(name) float MUTATOR_##name(float mode)
#define MUTATOR_HOOKFUNCTION(name) float HOOKFUNCTION_##name()
#define MUTATOR_HOOK(cb,func,order) do { if(mode == MUTATOR_ADDING) { if(!HOOK_##cb) HOOK_##cb = CallbackChain_New(#cb); if(!CallbackChain_Add(HOOK_##cb,HOOKFUNCTION_##func,order)) { print("HOOK FAILED: ", #func, "\n"); return 1; } } else if(mode == MUTATOR_REMOVING) { if(HOOK_##cb) CallbackChain_Remove(HOOK_##cb,HOOKFUNCTION_##func); } } while(0)
#define MUTATOR_ONADD if(mode == MUTATOR_ADDING)
#define MUTATOR_ONREMOVE if(mode == MUTATOR_REMOVING)

#define MUTATOR_HOOKABLE(cb) entity HOOK_##cb
#define MUTATOR_CALLHOOK(cb) CallbackChain_Call(HOOK_##cb)

#define MUTATOR_RETURNVALUE CallbackChain_ReturnValue




// register all possible hooks here

MUTATOR_HOOKABLE(MakePlayerObserver);
	// called when a player becomes observer, after shared setup

MUTATOR_HOOKABLE(PlayerSpawn);
	entity spawn_spot; // spot that was used, or world
	// called when a player spawns as player, after shared setup, before his weapon is chosen (so items may be changed in here)

MUTATOR_HOOKABLE(ClientDisconnect);
	// called when a player disconnects

MUTATOR_HOOKABLE(PlayerDies);
	// called when a player dies to e.g. remove stuff he was carrying.
	// INPUT:
		entity frag_inflictor;
		entity frag_attacker;
		entity frag_target; // same as self

MUTATOR_HOOKABLE(GiveFragsForKill);
	// called when someone was fragged by "self", and is expected to change frag_score to adjust scoring for the kill
	// INPUT:
		entity frag_attacker; // same as self
		entity frag_target;
	// INPUT, OUTPUT:
		float frag_score;

MUTATOR_HOOKABLE(MatchEnd);
	// called when the match ends

MUTATOR_HOOKABLE(GetTeamCount);
	// should adjust ret_float to contain the team count
	// INPUT, OUTPUT:
		float ret_float;

MUTATOR_HOOKABLE(SpectateCopy);
	// copies variables for spectating "other" to "self"
	// INPUT:
		entity other;

MUTATOR_HOOKABLE(ForbidThrowCurrentWeapon);
	// returns 1 if throwing the current weapon shall not be allowed

MUTATOR_HOOKABLE(SetStartItems);
	// adjusts {warmup_}start_{items,weapons,ammo_{cells,rockets,nails,shells,fuel}}

MUTATOR_HOOKABLE(BuildMutatorsString);
	// appends ":mutatorname" to ret_string for logging
	// INPUT, OUTPUT:
		string ret_string;

MUTATOR_HOOKABLE(BuildMutatorsPrettyString);
	// appends ", Mutator name" to ret_string for display
	// INPUT, OUTPUT:
		string ret_string;

MUTATOR_HOOKABLE(FilterItem);
	// checks if the current item may be spawned (self.items and self.weapons may be read and written to, as well as the ammo_ fields)
	// return error to request removal

MUTATOR_HOOKABLE(TurretSpawn);
	// return error to request removal
	// INPUT: self - turret
	
MUTATOR_HOOKABLE(OnEntityPreSpawn);
	// return error to prevent entity spawn, or modify the entity

MUTATOR_HOOKABLE(PlayerPreThink);
	// runs in the event loop for players; is called for ALL player entities, also bots, also the dead, or spectators

MUTATOR_HOOKABLE(GetPressedKeys);
	// TODO change this into a general PlayerPostThink hook?

MUTATOR_HOOKABLE(PlayerPhysics);
	// called before any player physics, may adjust variables for movement,
	// is run AFTER bot code and idle checking

MUTATOR_HOOKABLE(GetCvars);
	// is meant to call GetCvars_handle*(get_cvars_s, get_cvars_f, cvarfield, "cvarname") for cvars this mutator needs from the client
	// INPUT:
		float get_cvars_f;
		string get_cvars_s;

MUTATOR_HOOKABLE(EditProjectile);
	// can edit any "just fired" projectile
	// INPUT:
		entity self;
		entity other;

MUTATOR_HOOKABLE(PlayerDamage_SplitHealthArmor);
	// called when a player gets damaged to e.g. remove stuff he was carrying.
	// INPUT:
		entity frag_inflictor;
		entity frag_attacker;
		entity frag_target; // same as self
		vector damage_force; // NOTE: this force already HAS been applied
	// INPUT, OUTPUT:
		float damage_take;
		float damage_save;
		
MUTATOR_HOOKABLE(PlayerDamage_Calculate);
	// called to adjust damage and force values which are applied to the player, used for e.g. strength damage/force multiplier or runematch runes
	// i'm not sure if I should change this around slightly (Naming of the entities, and also how they're done in g_damage).
	// INPUT:
		entity frag_attacker;
		entity frag_target;
		float frag_deathtype;
	// INPUT, OUTPUT:
		float frag_damage;
		vector frag_force;

MUTATOR_HOOKABLE(PlayerPowerups);
	// called at the end of player_powerups() in cl_client.qc, used for manipulating the values which are set by powerup items.
	// INPUT
	entity self;
	float olditems; // also technically output, but since it is at the end of the function it's useless for that :P 

MUTATOR_HOOKABLE(PlayerUseKey);
	// called when the use key is pressed
	// if MUTATOR_RETURNVALUE is 1, don't do anything
	// return 1 if the use key actually did something

MUTATOR_HOOKABLE(SV_ParseClientCommand);
	// called when a client command is parsed
	// NOTE: hooks MUST start with if(MUTATOR_RETURNVALUE) return 0;
	// NOTE: return 1 if you handled the command, return 0 to continue handling
	// NOTE: THESE HOOKS MUST NEVER EVER CALL tokenize()
	// INPUT
	string cmd_name; // command name
	float cmd_argc; // also, argv() can be used
	string cmd_string; // whole command, use only if you really have to
	/*
		// example:
		MUTATOR_HOOKFUNCTION(foo_SV_ParseClientCommand)
		{
			if(MUTATOR_RETURNVALUE) // command was already handled?
				return 0;
			if(cmd_name == "echocvar" && cmd_argc >= 2)
			{
				print(cvar_string(argv(1)), "\n");
				return 1;
			}
			if(cmd_name == "echostring" && cmd_argc >= 2)
			{
				print(substring(cmd_string, argv_start_index(1), argv_end_index(-1) - argv_start_index(1)), "\n");
				return 1;
			}
			return 0;
		}
	*/

MUTATOR_HOOKABLE(Spawn_Score);
	// called when a spawnpoint is being evaluated
	// return 1 to make the spawnpoint unusable
	// INPUT
	entity self; // player wanting to spawn
	entity spawn_spot; // spot to be evaluated
	// IN+OUT
	vector spawn_score; // _x is priority, _y is "distance"

MUTATOR_HOOKABLE(SV_StartFrame);
	// runs globally each server frame
