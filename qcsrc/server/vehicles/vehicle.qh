#ifndef VEHICLE_H
#define VEHICLE_H

#include "../_all.qh"

#include "../antilag.qh"
#include "../cl_player.qh"
#include "../g_damage.qh"
#include "../g_hook.qh"
#include "../g_subs.qh"
#include "../movelib.qh"

#include "../bot/bot.qh"

#include "../command/common.qh"

#include "../tturrets/include/turrets_early.qh"

#include "../weapons/tracing.qh"

#include "../../common/deathtypes.qh"
#include "../../common/stats.qh"

#include "../../warpzonelib/anglestransform.qh"
#include "../../warpzonelib/server.qh"

entity vehicles_projectile(string _mzlfx, string _mzlsound,
                           vector _org, vector _vel,
                           float _dmg, float _radi, float _force,  float _size,
                           float _deahtype, float _projtype, float _health,
                           float _cull, float _clianim, entity _owner);

vector vehicles_findgoodexit(vector prefer_spot);



/** vehicles_locktarget

    Generic target locking.

    Figure out if what target is "locked" (if any), for missile tracking as such.

    after calling, "if(self.lock_target != world && self.lock_strength == 1)" mean
    you have a locked in target.

    Exspects a crosshair_trace() or equivalent to be
    dont before calling.

**/
.entity lock_target;
.float  lock_strength;
.float  lock_time;
.float  lock_soundtime;

void UpdateAuxiliaryXhair(entity own, vector loc, vector clr, int axh_id);

vector vehicle_aimturret(entity _vehic, vector _target, entity _turrret, string _tagname,
                         float _pichlimit_min, float _pichlimit_max,
                         float _rotlimit_min, float _rotlimit_max, float _aimspeed);

#define VEHICLE_UPDATE_PLAYER(ply,fld,vhname) \
ply.vehicle_##fld = (self.vehicle_##fld / autocvar_g_vehicle_##vhname##_##fld) * 100

void CSQCVehicleSetup(entity own, float vehicle_id);

.float() PlayerPhysplug;

float autocvar_g_vehicles_allow_bots = 0;

void vehicles_touch();

void vehicles_regen(float timer, .float regen_field, float field_max, float rpause, float regen, float delta_time, float _healthscale);

float shortangle_f(float ang1, float ang2);
float anglemods(float v);

entity vehicle_tossgib(entity _template, vector _vel, string _tag, float _burn, float _explode, float _maxtime, vector _rot);

void vehicles_impact(float _minspeed, float _speedfac, float _maxpain);

void shieldhit_think();

float vehicle_addplayerslot(    entity _owner,
                                entity _slot,
                                float _hud,
                                string _hud_model,
                                float() _framefunc,
                                void(float) _exitfunc);

.void() vehicle_impact;

float vehicle_initialize(string  net_name,
                         string  bodymodel,
                         string  topmodel,
                         string  hudmodel,
                         string  toptag,
                         string  hudtag,
                         string  viewtag,
                         float   vhud,
                         vector  min_s,
                         vector  max_s,
                         float   nodrop,
                         void(float _spawnflag)  spawnproc,
                         float   _respawntime,
                         float() physproc,
                         void()  enterproc,
                         void(float extflag) exitfunc,
                         void() dieproc,
                         void() thinkproc,
                         float  use_csqc,
                         float _max_health,
                         float _max_shield);

float  force_fromtag_normpower;

void vehicles_painframe();

void vehicles_locktarget(float incr, float decr, float _lock_time);

vector vehicles_force_fromtag_maglev(string tag_name, float spring_length, float max_power);

vector vehicles_force_fromtag_hover(string tag_name, float spring_length, float max_power);

void vehicles_projectile_explode();

#if VEHICLES_ENABLED

.int vehicle_flags;
const int VHF_ISVEHICLE     = BIT(1);    /// Indicates vehicle
const int VHF_HASSHIELD     = BIT(2);    /// Vehicle has shileding
const int VHF_SHIELDREGEN   = BIT(3);    /// Vehicles shield regenerates
const int VHF_HEALTHREGEN   = BIT(4);   /// Vehicles health regenerates
const int VHF_ENERGYREGEN   = BIT(5);   /// Vehicles energy regenerates
const int VHF_DEATHEJECT    = BIT(6);   /// Vehicle ejects pilot upon fatal damage
const int VHF_MOVE_GROUND   = BIT(7);  /// Vehicle moves on gound
const int VHF_MOVE_HOVER    = BIT(8);  /// Vehicle hover close to gound
const int VHF_MOVE_FLY      = BIT(9);  /// Vehicle is airborn
const int VHF_DMGSHAKE      = BIT(10); /// Add random velocity each frame if health < 50%
const int VHF_DMGROLL       = BIT(11); /// Add random angles each frame if health < 50%
const int VHF_DMGHEADROLL   = BIT(12); /// Add random head angles each frame if health < 50%
const int VHF_MULTISLOT     = BIT(13); /// Vehicle has multiple player slots
const int VHF_PLAYERSLOT    = BIT(14);    /// This ent is a player slot on a multi-person vehicle

.entity gun1;
.entity gun2;
.entity gun3;
.entity vehicle_shieldent;  /// Entity to disply the shild effect on damage
.entity vehicle;
.entity vehicle_viewport;
.entity vehicle_hudmodel;
.entity vehicle_controller;

.entity gunner1;
.entity gunner2;

.float vehicle_health;      /// If self is player this is 0..100 indicating precentage of health left on vehicle. If self is vehile, this is the real health value.
.float vehicle_energy;      /// If self is player this is 0..100 indicating precentage of energy left on vehicle. If self is vehile, this is the real energy value.
.float vehicle_shield;      /// If self is player this is 0..100 indicating precentage of shield left on vehicle. If self is vehile, this is the real shield value.

.float vehicle_ammo1;   /// If self is player this field's use depends on the individual vehile. If self is vehile, this is the real ammo1 value.
.float vehicle_reload1; /// If self is player this field's use depends on the individual vehile. If self is vehile, this is the real reload1 value.
.float vehicle_ammo2;   /// If self is player this field's use depends on the individual vehile. If self is vehile, this is the real ammo2 value.
.float vehicle_reload2; /// If self is player this field's use depends on the individual vehile. If self is vehile, this is the real reload2 value.

.float sound_nexttime;
const float VOL_VEHICLEENGINE = 1;

.float hud;
.float dmg_time;
.float  vehicle_respawntime;
//.void() vehicle_spawn;

void vehicles_exit(float eject);
.void(float exit_flags) vehicle_exit;
const float VHEF_NORMAL = 0;  /// User pressed exit key
const float VHEF_EJECT  = 1;  /// User pressed exit key 3 times fast (not implemented) or vehile is dying
const float VHEF_RELESE = 2;  /// Release ownership, client possibly allready dissconnected / went spec / changed team / used "kill" (not implemented)

const float SVC_SETVIEWPORT   = 5;   // Net.Protocol 0x05
const float SVC_SETVIEWANGLES = 10;  // Net.Protocol 0x0A
const float SVC_UPDATEENTITY  = 128; // Net.Protocol 0x80

.void() vehicle_enter;  /// Vehicles custom funciton to be executed when owner exit it
.void() vehicle_die;    /// Vehicles custom function to be executed when vehile die
const float VHSF_NORMAL = 0;
const float VHSF_FACTORY = 2;
.void(float _spawnflag) vehicle_spawn;  /// Vehicles custom fucntion to be efecuted when vehicle (re)spawns
.float(float _imp) vehicles_impulse;
.float vehicle_weapon2mode;

#if VEHICLES_USE_ODE
void(entity e, float physics_enabled) physics_enable = #540; // enable or disable physics on object
void(entity e, vector force, vector force_pos) physics_addforce = #541; // apply a force from certain origin, length of force vector is power of force
void(entity e, vector torque) physics_addtorque = #542; // add relative torque
#endif  // VEHICLES_USE_ODE
#endif  // VEHICLES_ENABLED
#endif
