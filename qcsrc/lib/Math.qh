#ifndef MATH_H
#define MATH_H

void mean_accumulate(entity e, .float a, .float c, float mean, float value, float weight)
{
	if (weight == 0)
		return;
	if (mean == 0)
		e.(a) *= pow(value, weight);
	else
		e.(a) += pow(value, mean) * weight;
	e.(c) += weight;
}

float mean_evaluate(entity e, .float a, .float c, float mean)
{
	if (e.(c) == 0)
		return 0;
	if (mean == 0)
		return pow(e.(a), 1.0 / e.(c));
	else
		return pow(e.(a) / e.(c), 1.0 / mean);
}

#define MEAN_ACCUMULATE(prefix,v,w) mean_accumulate(self,prefix##_accumulator,prefix##_count,prefix##_mean,v,w)
#define MEAN_EVALUATE(prefix) mean_evaluate(self,prefix##_accumulator,prefix##_count,prefix##_mean)
#define MEAN_DECLARE(prefix,m) float prefix##_mean = m; .float prefix##_count, prefix##_accumulator

/*
==================
crandom

Returns a random number between -1.0 and 1.0
==================
*/
float crandom (void)
{
	return 2 * (random () - 0.5);
}


/*
==================
Angc used for animations
==================
*/


float angc (float a1, float a2)
{
	float	a;

	while (a1 > 180)
		a1 = a1 - 360;
	while (a1 < -179)
		a1 = a1 + 360;

	while (a2 > 180)
		a2 = a2 - 360;
	while (a2 < -179)
		a2 = a2 + 360;

	a = a1 - a2;
	while (a > 180)
		a = a - 360;
	while (a < -179)
		a = a + 360;

	return a;
}

float fsnap(float val,float fsize)
{
    return rint(val / fsize) * fsize;
}

vector vsnap(vector point,float fsize)
{
    vector vret;

    vret.x = rint(point.x / fsize) * fsize;
    vret.y = rint(point.y / fsize) * fsize;
    vret.z = ceil(point.z / fsize) * fsize;

    return vret;
}

vector lerpv(float t0, vector v0, float t1, vector v1, float t)
{
	return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
}

#endif
